---
params:
  projectdir: null # Use when loading. If null, here::here() will be used. Can also hard code if for some reason you need that
  project_title: "Test"    # Change depending on your project name
  researcher_name: "Name" # Name of the researcher leading the project
  bioinformatician_name: "Name" # Name of the person running the R-ODAF analyses
  metadata_file: "metadata.txt" # Name of the metadata file. Must be in inputs/metadata/ 
  contrasts_file: "contrasts.txt" # Name of the contrasts file. Must be in inputs/contrasts/ 
  project_description: null # description of project for report, optional
  analysis_name: "default" # short string identifying analysis settings. This will appear in the analysis directory and file names
  batch_var: "batch"          # For example, multiple plates
  dose: "dose"               # If there is a dose in the experiment; otherwise use NULL
  platform: "TempO-Seq"      # TempO-Seq Or RNA-Seq
  nmr_threshold: 100000    # 10% of 1M reads for TempOSeq = 100,000; 10% of 10M reads for RNA-Seq = 1,000,000.
  write_additional_output: FALSE # export BMD, biomarker, and biosets output? facet variable should contain chemical and timepoint information
  celltype: "MCF7 cells" # only required for biosets output. Cell type or species used
  units: "uM" # only required for biosets output. Units of dose
  species: "human"                 # one of human, mouse, rat, hamster
  design: "group"                # single experimental group of interest; entries in this column must match the contrast names.
  intgroup: ["group"]            # experimental group of interest plus covariates; can be more than one
  intgroup_to_plot: ["group"]   # for PCA plots, add tabs for one or more groups to color
  formula_override: null # e.g., "~batch + condition", to enable users to specify the DESeq2 formula to use
  deseq_facet: "chemical"       # If you have many different experimental groups, you may subset the report by specifying a column in the metadata to filter groups, and then setting the group of interest in deseq_filter
  deseq_filter:  null        # Which group will this report be done on?
  reports_facet: null #  
  reports_filter:  null # 
  sortcol: "dose"                # Optionally, a column by which to sort the contrasts
  solvent_control: "solvent_control"
  lenient_contrasts: FALSE         # Use either column (exp, cont) of contrasts file to limit what is included in the report (instead of just exp column)
  strict_contrasts: FALSE         # Use BOTH columns (exp, cont) of contrasts file to limit what is included in the report
  exclude_samples: null      # Optionally, a vector of sample names to exclude from the analysis
  exclude_groups: null       # Optionally, a vector of groups to exclude from the analysis. By default this is assumed to be in the column specified by params$design.
  include_only_column:  null # Restrict analysis to group(s) in the column listed here based on params$include_only_group.
  include_only_group:  null  # Restrict analysis to this/these group(s) within the column listed in params$include_only_column
  cpus: 41                       # Set to a lower number (e.g., 2 to 4) if you aren't working in a server environment
  run_pathway_analysis: TRUE     # Optionally disable pathway analysis if not available for your organism
  wikipathways_directory: "~/shared/dbs/wikipathways"
  linear_fc_filter_DEGs: 1.5 # Default 1.5
  linear_fc_filter_biosets: 1.2 # Default 1.2. Used for biosets output when write_additional_output=True
  biospyder_dbs: "~/shared/dbs/biospyder/"
  biospyder_manifest_file:  "181019_Human_S1500_Surrogate_1.2_Manifest.txt"
  # "191113_Human_S1500_Surrogate_2.0_Manifest.csv"
  # "181019_Human_S1500_Surrogate_1.2_Manifest.txt"
  # "191004_Human_Whole_Transcriptome_2.0_Manifest.txt"
  wikipathways_filename: "wikipathways-20210810-gmt-Homo_sapiens.gmt"
  KEGGpathways_filename: "c2.cp.kegg_medicus.v2023.2.Hs.symbols.gmt"
  # "wikipathways-20210810-gmt-Mus_musculus.gmt"
  # "wikipathways-20210810-gmt-Rattus_norvegicus.gmt"
  nBestFeatures: 20              # The number of best features to make plots of their counts
  nBest: 100                     # Number of features to include in table and limiting PCA/clustering analysis
  nHeatmap: 50                   # Number of most variable genes for heatmap
  nHeatmapDEGs: 50               # Number of DEGs for heatmap
  cooks: FALSE                   # the DESeq Cook's distance cutoff, or FALSE to disable it
  filter_gene_counts: FALSE      # Filter genes to those with at least 1 count in 1 sample. Disabled by default for biomarker file output. Can enable to increase speed of analysis
  generate_main_report: TRUE
  generate_stats_report: TRUE
  generate_data_explorer_report: TRUE
  generate_go_pathway_report: TRUE
  generate_tgxddi_report: TRUE
  generate_tgxhdaci_report: TRUE
  generate_runningfisher_report: TRUE
  output_digits: 5
  parallel: FALSE
  species_data: null
  count_data_file: null
  sampledata_sep: null
  MinCount: null
  alpha: 0.05
  feature_id: null
  biospyder: null
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: spacelab           # flatly spacelab sandstone cerulean
    code_download: true
bibliography: "`r file.path(params$projectdir, 'references/tgx-hdaci-references.bib')`"

---


```{r docSetup, warning = FALSE, message = FALSE, include = F}
#### Record start time
startTime <- Sys.time()

library(tidyverse)
library(knitr)
library(kableExtra)
library(patchwork)
```

---
title: "`r params$platform` Running Fisher biomarker suite report"
---

# `r params$project_title` {-}

Date report generated: `r format(Sys.time(), '%d %B, %Y')`  

Report prepared by: `r params$bioinformatician_name`

Report prepared for: `r params$researcher_name`

***

```{r functions, echo=FALSE}
K <- function(bm, bioset){
	#Arguements are two ranked order lists of genes
	#Return the rankings for each common gene in the bioset
	rnk <- 1:length(bioset)
	K <- data.frame(ID = bm, Rank = 0)
	ID <- 1:length(bioset)

	for(j in 1:nrow(K)){
		flag <- bioset == K$ID[j]
		if(length(bioset[flag]) == 1) K$Rank[j] <- ID[flag]
	}
	K[K$Rank > 0,]
}

mat <- function(bm, bioset, N){
	n <- length(bm)
	x11 <- length(bioset[bioset %in% bm])
	x12 <- n - x11
	x21 <- length(bioset) - x11
	x22 <- N - x21 - x11 - x12
	matrix(c(x11, x21, x12, x22), ncol = 2)
}

test <- function(mat){
	pval <- fisher.test(mat, alternative = "greater")$p.value
	if(is.na(pval)){
		pval <- 2.2e-16
	}
	pval
}

runningFisher <- function(bm, bioset, N){
	score <- 0
	if(length(bm) > 0){
		Runs <- K(bm, bioset)
		if(length(Runs$ID) > 0){
			Runs$pval <- 1
			for(k in 1:nrow(Runs)){
				bs <- bioset[1:Runs$Rank[k]]
				m <- mat(bm, bs, N)				
				Runs$pval[k] <- test(m)
			}
			score <- min(Runs$pval*length(Runs$pval))
			if(score > 1) score <- 1
			-log10(score)
		} else {
			score
		}
	} else {
		score
	}
}

signedRF <- function(b1up, b1down, b2up, b2down, N){
	s1 <- runningFisher(b1up, b2up, N)
	s2 <- runningFisher(b1down, b2down, N)
	s3 <- runningFisher(b1up, b2down, N)
	s4 <- runningFisher(b1down, b2up, N)

	#Reverse order
	r1 <- runningFisher(b2up, b1up, N)
	r2 <- runningFisher(b2down, b1down, N)
	r3 <- runningFisher(b2up, b1down, N)
	r4 <- runningFisher(b2down, b1up, N)

	#The same procedure in this reverse direction produces another score for the same subset pair.
	#The 2 scores are averaged to represent the magnitude of the similarity between the 2 subsets.
	s1 <- (s1+r1)/2
	s2 <- (s2+r2)/2
	s3 <- (s3+r3)/2
	s4 <- (s4+r4)/2

	#The overall score is computed by summing up all directional subset pair scores. The sign of the 
	#sum determines whether the 2 signatures are positively or negatively correlated. Note a negative 
	#sign is given if Di and Dj are opposite (s3 and s4)
	score <- s1+s2-s3-s4
	score
}

RF <- function(bm, bioset, N){
	#bm <- bm[b][[1]]; bioset <- x

	#Rank order the values
	bm <- bm[order(abs(bm$Score), decreasing = TRUE),]

	b1up <- bm$ID[bm$Score > 0]
	b1down <- bm$ID[bm$Score < 0]

	b2up <- bioset$Gene[bioset$fc > 0]
	b2down <- bioset$Gene[bioset$fc < 0]

	signedRF(b1up, b1down, b2up, b2down, N)
}
```

```{r load_biomarkers, echo=FALSE}
bms <- dir(path = here::here("resources", "RF_biomarkers"), pattern = "Biomarker", full.names = TRUE)

nms <- c("AHR", "Aneugen1", "Aneugen2", "AR", "Genomark", "ERa50", "ERa46", "FattyLiver", "HIF1", "HSF1", "MTF1",
	"Nrf2", "PParHepaRG", "PParHH", "TGxDDI", "HDACiTk6", "HDACiHepaRG", "TGxTB", "TSA")

# Nested list of biomarkers with genes and scores
bm <- NULL

for(k in 1:length(bms)){
	tmp <- read.delim(bms[k])
	tmp <- tmp[,c(1,2)]
	names(tmp) <- c("ID", "Score")
	tmp <- tmp[order(abs(tmp$Score), decreasing = TRUE),]
	tmp$ID <- toupper(tmp$ID)
	bm$tmp <- tmp
	names(bm)[k] <- nms[k]
}
```

```{r load_biosets, echo=FALSE}
# # uncomment code to run interactively
# # Otherwise, the data will be loaded from bs by way of render_DESeq2_report.parallel.R
#data_file <- file.path(paths$RData, paste0(params$project_title, "_DEG_data.RData"))
#load(data_file)

# Rename the biosets to remove extra information (which clutters up the plots)
original_names <- names(bs)

rename_function <- function(name) {
  sub("(_[0-9.]+).*", "\\1", name)
}

new_names <- sapply(original_names, rename_function)
names(bs) <- new_names
# print(names(bs))

```

```{r run_RF, echo=FALSE}
# Need different values for N
# Depending on the biospyder kit?
# What about RNA-seq?

N <- 19694

out <- NULL
out2 <- data.frame(Compounds = names(bm))

for(f in 1:length(bs)){
	x <- bs[f][[1]]
	nms <- names(bs)[f]
	oo <- NULL
	for(b in 1:length(bm)){
		o <- RF(bm[b][[1]], x, N)
		o <- cbind.data.frame(data.frame(Chem = nms, Biomarker = names(bm)[b]), o)
		out <- rbind.data.frame(out, o)
		oo <- rbind.data.frame(oo,o)
	}
	out2 <- cbind.data.frame(out2, oo$o)
}

```

```{r plot_RF, echo=FALSE}
biomarkers <- c("AHR", "Aneugen1", "Aneugen2", "AR", "Genomark", "ERa50", "ERa46", "FattyLiver", "HIF1", "HSF1", "MTF1",
	"Nrf2", "PParHepaRG", "PParHH", "TGxDDI", "HDACiTk6", "HDACiHepaRG", "TGxTB", "TSA")


# Initialize an empty list to store ggplot objects for the combined plot
plot_list_combined <- list()

for (i in seq_along(unique(out$Biomarker))) {
  biomarker <- unique(out$Biomarker)[i]
  
  if (biomarker == "HDACiTk6" || biomarker == "Genomark") {
    threshold_hi <- 15
    threshold_lo <- -15
  } else {
    threshold_hi <- 4
    threshold_lo <- -4
  }

  j <- out %>% 
    filter(Biomarker == biomarker) %>%
    arrange(o, decreasing = TRUE) %>%
    mutate(Chemical = str_extract(Chem, "^[^_]+")) %>% 
    mutate(Chem = fct_reorder(Chem, o, .desc = TRUE))
  
  # Create the plot with full x-axis and y-axis labels
  p <- ggplot(j, aes(x = Chem, y = o, color = Chemical)) +
    geom_point(size = 3) +
    geom_hline(yintercept = threshold_hi, color = "black") +
    geom_hline(yintercept = threshold_lo, color = "black") +
    labs(title = biomarker,
         y = "-log10(p-value)",
         x = "Bioset") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
  
  # Save the individual plot
  # ggsave(paste0(biomarker, ".png"), plot = p, device = "png")

  # Append the modified plot to the list for the combined plot
  plot_list_combined[[biomarker]] <- p
}
# Combine the plots using patchwork with a shared legend
combined_plot <- wrap_plots(plot_list_combined, ncol = 3) +
  plot_layout(guides = "collect",
  axis_titles = "collect") +
  plot_annotation(
    title = NULL,
    subtitle = NULL,
    caption = NULL,
    theme = theme(
      plot.title = element_blank(),
      plot.subtitle = element_blank(),
      plot.caption = element_blank(),
      axis.title.x = element_text(size = 12, face = "bold"),
      axis.title.y = element_text(size = 12, face = "bold")
    )
  )
```

```{r plot_combined, echo=FALSE, fig.height=20, fig.width=10}
combined_plot
```

Ideally, I want a table here showing how many genes matched each biomarker from each contrast, something like this:

Biomarker | No. Genes | Matching contrast 1 | Matching contrast 2 | Matching contrast 3
--- | --- | --- | --- | ---
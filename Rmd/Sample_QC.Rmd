---
params:
  projectdir: null # Use when loading. If null, here::here() will be used. Can also hard code if for some reason you need that
  project_title: "Test"    # Change depending on your project name
  researcher_name: "Name" # Name of the researcher leading the project
  bioinformatician_name: "Name" # Name of the person running the R-ODAF analyses
  metadata_file: "metadata.txt" # Name of the metadata file. Must be in inputs/metadata/ 
  contrasts_file: "contrasts.txt" # Name of the contrasts file. Must be in inputs/contrasts/ 
  project_description: null # description of project for report, optional
  clust_method: "spearman" # For clustering
  studywide_tree_height_cutoff: 0.1  # For clustering
  group_tree_height_cutoff: 0.2
  dendro_color_by: "group" # Specify how you would like to color the dendrograms
  nmr_threshold: 100000    # 10% of 1M reads for TempOSeq = 100,000; 10% of 10M reads for RNA-Seq = 1,000,000.
  align_threshold: 0.5     # 50% alignment rate for TempO-Seq Experiments
  gini_cutoff: 0.95
  exp_groups:
    value:
      one: ["chemical", "dose"]
      #two: ["I7_Index_ID", "I5_Index_ID"]
      three: ["row", "column"]
    #4: ["batch"]
    #As many groups as desired...
  batch_var: "temposeq_plate"          # "batch"
  dose: "dose"               # If there is a dose in the experiment; otherwise use NULL
  treatment_var: "chemical"
  platform: "TempO-Seq"      # TempO-Seq Or RNA-Seq
  collapse_replicates: F # Set to true if you have replicate flow cells that need to be summed into a single value
  # Column names for metadata, if applicable
  technical_control: "technical_control"
  reference_rna: "reference_rna"
  solvent_control: "solvent_control"
  write_additional_output: TRUE # export BMD, biomarker, and biosets output? facet variable should contain chemical and timepoint information
  celltype: "Some cells" # only required for biosets output. Cell type or species used
  units: "uM" # only required for biosets output. Units of dose
  biospyder_dbs: "~/shared/dbs/biospyder/"
  biospyder_manifest_file:  "Human_S1500_1.2_standardized.csv"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: spacelab           # flatly spacelab sandstone cerulean
    code_download: true
bibliography: "`r file.path(params$projectdir, 'references/references.bib')`"
---

```{r setup, include=FALSE}
startTime <- Sys.time()
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# `r params$platform` - Study-wide sample quality control {-}
## `r params$project_title` {-}

Date report generated: `r format(Sys.time(), '%d %B, %Y')`  

Report prepared by: `r params$bioinformatician_name`

Report prepared for: `r params$researcher_name`

***

Modified from code provided by Andrew Williams (Health Canada) and recommendations from Joshua Harrill (US EPA) [@harrill2021high]. See [References].  

This script should be run prior to DEG/BMD analysis to remove any suspect samples from across the entire study.  

The purpose of this report is to provide objective metrics to assess sample quality. There may be a variety of reasons that samples should be excluded from your downstream analysis, such as poor quality sequence data or failed library construction, leading to poor alignments. This type of failure may be a direct result of biological or chemical factors such as low quality or low quantity RNA/DNA used as input.  

This script will automatically output a new sample metadata table that includes only the samples passing the metrics here; that sample metadata will be used as input to subsequent analysis steps, thereby excluding any samples from analysis that do not meet these standards. 


```{r load_libraries, message = F, warnings = F, echo = F}
library(edgeR)
library(ggplot2)
theme_set(theme_bw())
library(plotly)
library(data.table)
library(cluster)
library(Cairo)
library(sfsmisc)
library(fields)
library(heatmap3)
library(DESeq2)
library(tidyverse)
library(foreach)
library(doParallel)
library(UpSetR)
library(GGally)
library(pheatmap)
library(ComplexHeatmap)
library(kableExtra)
library(dendextend)
library(dendsort)
library(rrcov)
library(vtree) # Richard Webster and Nick Barrowman
library(ggh4x)
library(scales)
library(plotly)
```


```{r define_functions, message = F, warnings = F, echo = F}
# Maybe these functions should be in R.ODAF.utils?

# Collapse replicates, use if params$collapse_replicates == T
collapse_reps <- function(filepath) {
  df <- read.table(file = filepath,
           sep = "\t",
           header = TRUE)
  names(df) <- gsub(pattern = "_trimmed", replacement = "", x = names(df))
  df <- df %>% pivot_longer(cols = -c("X"),
                names_to = c('.value', 'flowcell'),
                names_pattern = '(.*)_(.*)')
  df[is.na(df)] <- 0
  sd_collapse <- data.table(df %>% dplyr::select(-c(flowcell)))
  results <- sd_collapse[, lapply(.SD, sum), by = "X"]
  return(results)
}

# Calculate GC content for TempO-Seq
calculate_gc <- function(seq) {
  n_gc <- stringr::str_count(seq, "G")
  n_c <- stringr::str_count(seq, "C")
  pct_gc <- ((n_gc + n_c)/stringr::str_length(seq))
  return(pct_gc)
}

# Function for sorting dendrograms
sort_hclust <- function(...) as.hclust(dendsort(as.dendrogram(...)))

# From EPA code?
countStats <- function(
  counts, 
  nsig = getOption("httrStatNsig", default = 0.8)
) {
  # Load required pkgs
	require(foreach)
  # Store results in a vector
	st <- vector()
	# Drop probes w/ no reads (this is for efficiency, should not impact final Nsig values)
	counts_nz <- counts[counts > 0]
	# Sort in decreasing order
	counts_nz <- sort(counts_nz, decreasing = T)
	# Compute cumulative sum of counts starting from highest count probe
	cumCounts <- cumsum(counts_nz)
	# Convert cumulative sums to cumulative proportions
	cumProp <- cumCounts / sum(counts_nz)
	# Compute the minimum number of probes to capture X% of total reads
	if (length(nsig) > 0) {
		ns <- foreach(prop = nsig, .combine = 'c') %do% {min(which(cumProp > prop))}
		names(ns) <- paste0("n_sig",nsig*100)
		st <- append(st, ns)
	}
	return(st)
}

add_spaces <- function(string) {
  substr(string, 1, 1) <- toupper(substr(string, 1, 1))
  string <- gsub(pattern = "-", replacement = " ", string)
  string <- gsub(pattern = "_", replacement = " ", string)
  string
}
```

```{r params, include = FALSE, echo = FALSE, message = FALSE}
exp_groups <- unname(params[["exp_groups"]]) # Include b/c of how things are addressed throughout.
```

```{r paths}
############################################################################
# File paths in project directory
############################################################################
paths <- R.ODAF.utils::set_up_filepaths(params)
knitr::opts_knit$set(root.dir = paths[["projectdir"]])
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r load_files, message = F, results = "hide"}
############################################################################
# FILES TO LOAD
############################################################################

# A. File with read counts
count_data_file <- file.path(paths$processed,"count_table.tsv")
if (params$collapse_replicates == T) {
  count_data <- collapse_reps(count_data_file)
  write.table(count_data,
              file = file.path(paths$processed,"count_table_collapsed.tsv"),
              sep = "\t",
              quote = F,
              row.names = F)
} else {
  count_data <- read.table(count_data_file,
                           sep = "\t",
                           stringsAsFactors = FALSE,
                           header = TRUE,
                           quote = "\"",
                           row.names = 1,
                           check.names = FALSE)
  multiQCFile <- file.path(paths$qc, "MultiQC_Report_data.zip")
  # NOTE won't this break if collapse_replicate is true? No multiQC loaded for later?
  multiqc_general_stats <- read.table(unz(multiQCFile, 'multiqc_star.txt'),
                                      header = TRUE, sep = "\t")
  mu <- data.frame(Sample = multiqc_general_stats$Sample,
                   FMR = multiqc_general_stats$uniquely_mapped_percent/100)
  row.names(mu) <- mu[,1]
}


# B. Tab delimited sample information file with at least 2 columns:
#    1. sample names identical to the column names of count_data
#    2. compound/group/whatever (needs to identify to which experimental group the sample belongs)
exp_metadata_file <- file.path(paths$metadata, params[["metadata_file"]])
# Check if the metadata was previously backed up.
# If so, restore it before doing the new manual sample removal.
# This is done to ensure we start with the full list of samples from the start.
if (file.exists(paste0(exp_metadata_file,".bak"))) {
    system(paste0("cp ",paste0(exp_metadata_file,".bak "),exp_metadata_file))
  }

exp_metadata <- read.delim(exp_metadata_file,
                          stringsAsFactors = FALSE,
                          sep = "\t",
                          header = TRUE,
                          quote = "\"",
                          row.names = NULL)

exp_metadata$original_names <- as.character(exp_metadata[,1])


# C. Manifest file for TempO-Seq
if (params$platform == "TempO-Seq") {
  manifest <- read.delim(
    file.path(params$biospyder_dbs, params$biospyder_manifest_file), # Assay manifest...
    stringsAsFactors = FALSE,
    sep = ",",
    header = TRUE,
    quote = "\"")
}

############################################################################
# Arrange tables by sample names
############################################################################

count_data <- count_data %>% dplyr::relocate(colnames(count_data) %>% sort())
ncol(count_data)

#design
d <- exp_metadata
d <- d %>% dplyr::arrange(original_names)
nrow(d)

############################################################################
#Checking row and column orderings
############################################################################
all(names(count_data) %in% d$original_names)
all(names(count_data) == d$original_names)
d <- d[d$original_names %in% names(count_data),]
exp_metadata <- d
all(names(count_data) == d$original_names)
# Useful if you want to analyze a reduced subset of data; relies on the metadata file used to filter sample data:
count_data <- count_data[, d$original_names]
mu <- mu[d$original_names, ]

############################################################################
# Re-order the data by group
############################################################################
flag_order <- order(d[,params$treatment_var])
d <- d[flag_order,]
count_data <- count_data[,d$original_names]

############################################################################
# CPM (used in dendrogram/cluster analysis)
############################################################################
libsize <- apply(count_data, 2, sum)
cpm <- count_data
for (k in 1:length(libsize)) {
  cpm[,k] <- log2((10^6)*(count_data[,k] + 0.5)/(libsize[k] + 1))
}



############################################################################
#Remove samples from a list manually
############################################################################
# Check if there's a file called remove.txt in metadata before proceeding...
remove_file <- file.path(paths$metadata,"remove.txt")
cytotoxic <- data.frame()
if (file.exists(remove_file)) {
  # How many groups in total are being input?
  exp_metadata %>% group_by(params[["treatment_var"]]) %>% dplyr::count()

  # Manual removal of some groups (e.g., cytotoxicity?)
  remove <- read.table(remove_file, sep="\t", header = F) %>% pull()
  # This should be recorded somehow... Todo.
  length(remove)

  # Best method is probably to use a list of unique sample IDs
  # By default, use the first column. This could be made more robust?
  # Should we add a parameter to specify the column to act on?  
  test <- exp_metadata %>% dplyr::filter(!.[[1]] %in% remove)
  cytotoxic <- exp_metadata %>% dplyr::filter(.[[1]] %in% remove)
  test %>% group_by(params[["treatment_var"]]) %>% dplyr::count()

  # Once above is correct, go ahead and make final filtered metadata
  exp_metadata <- exp_metadata %>% dplyr::filter(!.[[1]] %in% remove)
  # If you've already done this, don't overwrite the backup!
  if (!file.exists(paste0(exp_metadata_file,".bak"))) {
    system(paste0("cp ",exp_metadata_file," ",paste0(exp_metadata_file,".bak")))
  }
  write.table(exp_metadata,
              exp_metadata_file,
              sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
  d <- exp_metadata
}
```


```{r split_metadata}
############################################################################
# Split into experimental samples vs technical controls
############################################################################

tech_ctrl_names <- exp_metadata %>%
  dplyr::filter(.data[[params$technical_control]] == TRUE) %>%
  dplyr::pull(original_names)

sample_names <- exp_metadata %>%
  dplyr::filter(.data[[params$technical_control]] == FALSE) %>%
  dplyr::pull(original_names)

ref_samples <- exp_metadata %>%
  dplyr::filter(.data[[params$reference_rna]] == TRUE) %>%
  dplyr::pull(original_names)

```



# Summary Statistics

Below, you will find plots and a table showing the distribution of read metrics (quality, GC content, aligned reads, etc.).

```{r summary-stats}
# NOTE won't this break if collapse_replicate is true? No multiQC loaded in load_files line 202?
summary_stats <- pivot_longer(multiqc_general_stats, cols = -Sample)
stat_metrics <- summary_stats %>%
  group_by(name) %>%
  summarise(Mean=mean(value), Median=median(value))
ggplot(summary_stats %>%
         dplyr::filter(name %in% c("total_reads", "uniquely_mapped",
                       "uniquely_mapped_percent", "mismatch_rate",
                       "unmapped_mismatches_percent", "unmapped_other_percent",
                       "unmapped_tooshort_percent")),
       aes(x=name, y=value)) +
  geom_jitter(alpha = 0.1) +
  geom_violin(fill = "transparent") +
  facet_wrap(name~., scales = "free")

stat_metrics %>%
  kable(caption = "Summary statistics from the alignments for all samples") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")


```

# PCA

```{r pca_plot, fig.height = 7, echo=FALSE}
# Right now this only works for projects with chemical and dose
# Need to generalize,  maybe add parameters for which columns to use?

# Filter CPM data for experimental samples
experimental_samples <- exp_metadata %>%
  filter(!technical_control & !reference_rna & !solvent_control) %>%
  pull(original_names)

cpm_experimental <- cpm %>%
  dplyr::select(all_of(experimental_samples))

# Perform PCA
pca_result <- prcomp(t(cpm_experimental), scale. = TRUE)

# Create a data frame for plotting
pca_data <- as.data.frame(pca_result$x)
pca_data$sample <- rownames(pca_data)
pca_data <- merge(pca_data, exp_metadata, by.x = "sample", by.y = "original_names")

# Create a new column for dose levels
# Otherwise there can be way too many doses to plot
pca_data <- pca_data %>%
  mutate(chemical_dose = paste(chemical, dose, sep = "_")) %>%
  group_by(chemical) %>%
  mutate(dose_level = dense_rank(dose)) %>%
  ungroup()

# Convert dose_level to a factor
pca_data$dose_level <- as.factor(pca_data$dose_level)

p_pca <- plot_ly(data = pca_data, x = ~PC1, y = ~PC2,
color = ~chemical, symbol = ~dose_level, text = ~sample,
size = 3) %>%
layout(title = "PCA of Experimental Samples",
         xaxis = list(title = paste0("PC1 (", round(100 * summary(pca_result)$importance[2, 1], 1), "%)")),
         yaxis = list(title = paste0("PC2 (", round(100 * summary(pca_result)$importance[2, 2], 1), "%)")))

plotly::highlight(p_pca, on = "plotly_click", off = "plotly_doubleclick", color = "red")

```

# Correlations

## All samples

This shows the Pearson correlation of log2-normalized CPM of read counts across all samples.

```{r correlation_1, fig.width = 11, fig.height = 10}
ref_correlations_all <- cor(as.matrix(cpm),
                            method = "pearson")

correlation_df_all <- exp_metadata %>%
  filter(original_names %in% colnames(ref_correlations_all))

rownames(correlation_df_all) <- correlation_df_all$original_names
correlation_df_all <- correlation_df_all[colnames(ref_correlations_all),]

correlation_df_all_heatmap <- correlation_df_all[,c(unlist(exp_groups[[1]]),
                                                    params$technical_control,
                                                    params$reference_rna,
                                                    params$solvent_control)]

pheatmap(ref_correlations_all,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_col = correlation_df_all_heatmap)

```


## Experimental samples

This shows the Pearson correlation of log2-normalized CPM of read counts across experimental samples.  Technical controls are excluded.

This first plot shows every sample in the study:

```{r correlation_2, fig.width = 11, fig.height = 10}
ref_correlations_samples <- cor(as.matrix(cpm %>%
                                            dplyr::select(all_of(sample_names))),
                                method = "pearson")

correlation_df_samples <- exp_metadata %>%
  filter(original_names %in% colnames(ref_correlations_samples))

rownames(correlation_df_samples) <- correlation_df_samples$original_names
correlation_df_samples <- correlation_df_samples[colnames(ref_correlations_samples),]

correlation_df_samples_heatmap <- correlation_df_samples[,c(unlist(exp_groups[[1]]),
                                                            params$technical_control,
                                                            params$reference_rna,
                                                            params$solvent_control)]

pheatmap(ref_correlations_samples,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_col = correlation_df_samples_heatmap)

```


## Reference RNA

This tests the Pearson correlation of log2-normalized CPM of read counts. If your data includes reference RNA, it should be shown here. If your data includes two sources of reference RNA, the same standard mix should shower higher correlations than between different standards. The correlations for the same standards across different batches/plates should be relatively high.

```{r correlation_3, fig.width = 11, fig.height = 10, eval=(length(ref_samples) > 0)}
ref_correlations <- cor(as.matrix(cpm %>% dplyr::select(all_of(ref_samples))),
                          method = "pearson")

correlation_df <- exp_metadata %>%
  filter(original_names %in% colnames(ref_correlations))

row.names(correlation_df) <- correlation_df$original_names
correlation_df <- correlation_df[colnames(ref_correlations),]

# This by default includes all the variables in the first "group" parameter
# For example, if you have multiple chemicals and multiple doses
# Those will likely be in your groups[[1]] variable
correlation_df <- correlation_df[,unlist(exp_groups[[1]]), drop = F]

pheatmap(ref_correlations,
         annotation_col = correlation_df,
         display_numbers = T)
         #cutree_cols = 2, # This is nice to have but won't work with small groups
         #cutree_rows = 2)

heatmap_colors <- circlize::colorRamp2(c(0.7, 1), c("blue", "red")) # NOTE: This never gets used...

annotation_col <- HeatmapAnnotation(df = correlation_df) # NOTE: I don't think this gets used either

```


# Sample Filtering 

## Quality control criteria

Quality control of each sample is performed according to the criteria laid out in @harrill2021high, 
plus an additional filter for the distance between samples in hierarchical clustering, suggested by Andrew Williams (Health Canada). 
In some projects, using a whole-study clustering distance cutoff may not be appropriate.
For example, if your study includes multiple cell lines, the whole-study clustering distance will be high because the cell lines are biologically distinct.
In that case, the whole-study clustering distance cutoff should be set high (for example, 0.9), and group-specific clustering distance cutoff should be used instead.

```{r criteria_table}

criteria <- data.frame(
  Abbreviation = c("Dendrogram", "Group Dendrogram", "NMR", "FMR", "Ncov5", "Nsig80", "GiC"),
  Description = c("All-samples clustering distance",
                  "Group-specific clustering distance",
                  "Number of mapped reads",
                  "Fraction of uniquely mapped reads", 
                  "Number of probes with at least 5 uniquely mapped reads", 
                  "Number of probes capturing the top 80% of a signal in a sample", 
                  "Gini coefficient"),
  "Default Threshold" = c("< 0.1",
                          "N/A",
                          "> 10% of target read depth",
                          "> 0.5",
                          "within 3*IQR",
                          "within 3*IQR",
                          "RNA-Seq: < 0.99, \nTempO-Seq: < 0.95"),
  "Threshold" = c(
    paste0("< ",params$studywide_tree_height_cutoff),
    paste0("<", params$group_tree_height_cutoff),
    paste0("> ",params$nmr_threshold),
    paste0("> ",params$align_threshold), 
    "within 3*IQR", "within 3*IQR", 
    paste0("< ",params$gini_cutoff)
  )
)

# Generate and style the table
criteria %>%
  kable("html", caption = "Criteria Table",
        col.names = c("Abbreviation", "Description", "Default Threshold", "Threshold")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


## Samples Removed Manually

If samples were removed due to the results of cytotoxicity assays or other experimentally-determined reasons, they are listed here.

In this experiment, `r nrow(cytotoxic)` samples were removed manually, from the following groups:

`r if (!is.null(remove)) { print(remove) }`

```{r}
if (nrow(cytotoxic) >= 1) {
  cytotoxic %>%
    kable(caption = "Samples removed manually before this report was generated.") %>%
    kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
    scroll_box(width = "100%", height = "480px")
}
```


## Samples Removed by QC metrics {.tabset}

Click on the tabs below to view samples removed by each metric.

```{r create_qaqc, results='asis', echo=FALSE}
# Initial Creation of QAQC
QAQC <- data.frame(Sample = names(count_data), NMR = apply(count_data, 2, sum))

# Adding Fraction of Mapped Reads (FMR)
QAQC <- QAQC %>% left_join(mu, by = "Sample")

# Adding Number of Active Probes (Ncov5)
n_genes <- nrow(count_data)
QAQC$Ncov5 <- apply(count_data, 2, function(x) length(x[x > 4])) / nrow(count_data)

# Adding Number of Probes Capturing 80% of Signal (Nsig80)
QAQC$Nsig80 <- apply(count_data, 2, countStats)

# Adding Gini Coefficient
QAQC$Gini <- apply(count_data, 2, function(x) gini(x))
```

### Clustering Distance Cutoff

A `r params$clust_method` distance of `r params$studywide_tree_height_cutoff` is used to cut the tree and separate outliers.

```{r filtering_dendrogram}
############################################################################
# Filtering
############################################################################

dendro_before_all_samples <- 1 - cor(as.matrix(cpm), method = params$clust_method)
dendro_before_all_samples <- sort_hclust(hclust(as.dist(dendro_before_all_samples), method = "average"))

dendro_before_all_samples <- as.dendrogram(dendro_before_all_samples)

tree_groups <- cutree(dendro_before_all_samples, h = params$studywide_tree_height_cutoff)
n <- table(tree_groups)
n <- sort(n, decreasing = T)

if (!is.null(dim(n))) {
  n <- n[2:dim(n)]
  
  if (length(n > 0)) {
    flag_cluster <- d$original_names %in% names(tree_groups[tree_groups %in% as.integer(names(n))])
    write.table(d[flag_cluster,],
                file.path(paths$details, "outliers_cluster_analysis.txt"),
                sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
    d[flag_cluster,] %>%
      dplyr::select(original_names, params$dendro_color_by) %>%
      kable(caption = "Samples flagged as outliers by clustering distance") %>%
      kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
      scroll_box(width = "100%", height = "480px")
  }
}

QAQC$dendrogram <- "PASS"
if (exists("flag_cluster")) {
  QAQC$dendrogram[which(QAQC$Sample %in% d$original_names[flag_cluster])] <- "FAIL"
}

```


### Group-specific Clustering Distance Cutoff
```{r group-correlation-setup}
# Perform the analysis, save results into QAQC dataframe, and generate dendrograms

exp_metadata_exp_samples <- exp_metadata %>% dplyr::filter(original_names %in% all_of(sample_names))

facets <- unique(exp_metadata_exp_samples[,params$treatment_var])
cor_list <- list()

# Create list to populate with dataframes for each treatment_var group
df_groupdendro_list <- list()
dendrograms <- list()

if(!is.na(params$group_tree_height_cutoff)) {
  for (i in seq_along(facets)) {
    samples_in_facet <- exp_metadata_exp_samples[exp_metadata_exp_samples[params$treatment_var] == facets[i],
                                                 "original_names"]
    if (length(samples_in_facet) < 2) { next }
    cpm_subset <- as.matrix(cpm %>% dplyr::select(all_of(samples_in_facet)))

    ### Filtering by dendrogram distance within each treatment group ###
    dendro_facet <- 1 - cor(cpm_subset, method = params$clust_method)
    dendro_facet <- sort_hclust(hclust(as.dist(dendro_facet), method = "average"))
    dendro_facet <- as.dendrogram(dendro_facet)

    facet_tree_groups <- cutree(dendro_facet, h = params$group_tree_height_cutoff)
    n_facet <- table(facet_tree_groups)
    n_facet <- sort(n_facet, decreasing = T)

    d_facet <- d %>% dplyr::filter(original_names %in% samples_in_facet)
    if (!is.null(dim(n_facet))) {
      n_facet <- n_facet[2:dim(n_facet)]

      if (length(n_facet > 0)) {
        flag_cluster_facet <- d_facet$original_names %in% names(facet_tree_groups[facet_tree_groups %in% as.integer(names(n_facet))])
      }
    } else {
      flag_cluster_facet <- rep(FALSE, nrow(d_facet))
    }

    # Add clustering results column to dataframe
    d_facet$flag_cluster_facet <- flag_cluster_facet

    df_groupdendro_list[[i]] <- d_facet

    # Save dendrogram
    dendrograms[[facets[i]]] <- dendro_facet
  }
}

if(!is.na(params$group_tree_height_cutoff)) {
  df_groupdendro <- do.call(rbind, df_groupdendro_list)
  df_groupdendro <- df_groupdendro %>% 
    dplyr::select(sample_ID, flag_cluster_facet) %>%
    dplyr::rename(group_dendrogram = flag_cluster_facet)
  df_groupdendro$group_dendrogram <- ifelse(df_groupdendro$group_dendrogram, "FAIL", "PASS")
} else {
  # If no tree height cutoff is specified, all samples are considered to pass
  df_groupdendro <- exp_metadata %>% 
    dplyr::select(sample_ID) %>%
    dplyr::mutate(group_dendrogram = "PASS")
}

# Incorporate info into QAQC table
QAQC <- merge(QAQC, df_groupdendro, by.x = "Sample", by.y = "sample_ID", all.x = TRUE)

# Table of samples failing
failed_groupdendro <- QAQC[QAQC$group_dendrogram == "FAIL",]

d %>%
  dplyr::filter(original_names %in% failed_groupdendro$Sample) %>%
  dplyr::select(original_names, params$dendro_color_by) %>%
  kable(caption = "Samples flagged with too few mapped reads") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")

```


### Number of mapped reads

Samples with less than `r params$nmr_threshold` aligned reads removed.

```{r num_mapped_reads}
######################################################################################
# Additional QC Metrics
######################################################################################
# NMR Number of mapped reads, defined as sum of total read counts summed over all detected probes
######################################################################################
# Reject < 10% of target depth
# Removes various types of failed samples

failed_read_threshold <- QAQC[QAQC$NMR < params$nmr_threshold,]

# Samples failing
d %>%
  dplyr::filter(original_names %in% failed_read_threshold$Sample) %>%
  dplyr::select(original_names, params$dendro_color_by) %>%
  kable(caption = "Samples flagged with too few mapped reads") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")

```

### Fraction of mapped reads

Samples less than `r params$align_threshold` aligned reads removed.

```{r fraction_mapped_reads}
failed_alignment_threshold <- QAQC[QAQC$FMR < params$align_threshold,]
  
# Samples failing
d %>%
  dplyr::filter(original_names %in% failed_alignment_threshold$Sample) %>%
  dplyr::select(original_names, params$dendro_color_by) %>%
  kable(caption = "Samples flagged as failing alignment threshold") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```

### Number of active probes

The number of probes having >5 uniquely mapped reads are calculated. Outliers on that metric (i.e., outside 3XIQR) are removed from analysis.

```{r ncov5}
######################################################################################
# Ncov5 The number of probes with at least 5 uniquely mapped reads.
######################################################################################
# Tukey's Outer Fence cutoff - 3*IQR
percent_active_probes <- boxplot(QAQC$Ncov5, range = 3, plot = F)
failed_Ncov5 <- QAQC[QAQC$Ncov5 < percent_active_probes$stats[1,1],]

# Samples failing
d %>%
  dplyr::filter(original_names %in% failed_Ncov5$Sample) %>%
  dplyr::select(original_names, params$dendro_color_by) %>%
  kable(caption = "Samples flagged as outliers with few active probes") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```

### Number of probes capturing 80% of signal

The number of probes capturing 80% of the signal is first calculated, and samples falling outside of 3X IQR are removed from downstream analysis.

```{r nsig80}
######################################################################################
# Nsig80 - The number of probes capturing the top 80% of signal in a sample.
######################################################################################
# Tukey's Outer Fence cutoff - 3*IQR
# (include test samples, vehicle controls, and reference chemical treatments)

probes_capturing_top_80 <- boxplot(QAQC$Nsig80, range = 3, plot = F)
failed_Nsig80 <- QAQC[QAQC$Nsig80 < probes_capturing_top_80$stats[1,1],]

# Samples failing
d %>%
  dplyr::filter(original_names %in% failed_Nsig80$Sample) %>%
  dplyr::select(original_names, params$dendro_color_by) %>%
  kable(caption = "Samples flagged as outliers for the proportion of probes contributing to the data") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")

```

### Gini coefficient

The Gini coefficient is computed for each sample based on the distribution of raw counts for all probes including those with 0 aligned reads. Samples with Gini coefficients >`r params$gini_cutoff` are removed from the analysis.

```{r gini}
######################################################################################
# Gini coefficient - Gini coefficient computed for each sample based on the distribution of 
# raw counts for all probes including those with 0 aligned reads
######################################################################################
# Reject > 0.95
failed_gini <- QAQC[QAQC$Gini > params$gini_cutoff,]

# Samples failing
d %>%
  dplyr::filter(original_names %in% failed_gini$Sample) %>%
  dplyr::select(original_names, params$dendro_color_by ) %>%
  kable(caption = "Samples flagged as failing the Gini coefficient") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```



```{r return_data}

################################################################################
# Add Dendrogram Clustering Pass/Fail to QAQC
################################################################################

failed_dendro_clustering <- QAQC[QAQC$Denodogram == "FAIL",]

# Samples failing
d %>%
  dplyr::filter(original_names %in% failed_dendro_clustering$Sample) %>%
  dplyr::pull(params$treatment_var)

################################################################################
# Removing Outliers
################################################################################
QAQC_pass_fail <- QAQC
QAQC_pass_fail$NMR <- cut(QAQC$NMR,
                          c(-Inf, params$nmr_threshold, Inf),
                          labels = c("FAIL", "PASS"), right = F)
QAQC_pass_fail$FMR <- cut(QAQC$FMR,
                          c(-Inf, params$align_threshold, Inf),
                          labels = c("FAIL", "PASS"), right = F)
QAQC_pass_fail$Ncov5 <- cut(QAQC$Ncov5,
                            c(-Inf, percent_active_probes$stats[1,1], Inf),
                            labels = c("FAIL", "PASS"), right = F)
QAQC_pass_fail$Nsig80 <- cut(QAQC$Nsig80,
                             c(-Inf, probes_capturing_top_80$stats[1,1], Inf),
                             labels = c("FAIL", "PASS"), right = F)
QAQC_pass_fail$Gini <- cut(QAQC$Gini,
                           c(-Inf, params$gini_cutoff, Inf),
                           labels = c("PASS", "FAIL"), right = F)


QAQC_failed <- QAQC_pass_fail %>%
  dplyr::rowwise() %>% 
  dplyr::filter_all(any_vars(str_detect(., pattern = "FAIL")))

#QAQC_failed_logical <- as.data.frame(QAQC_failed)
QAQC_failed_logical <- lapply(QAQC_failed, as.character)
QAQC_failed_logical <- as.data.frame(QAQC_failed_logical)
QAQC_failed_logical[QAQC_failed_logical == "FAIL"] <- 1
QAQC_failed_logical[QAQC_failed_logical == "PASS"] <- 0
#apply(QAQC_failed_logical_matrix, 2, as.numeric)

QAQC_failed_logical <- QAQC_failed_logical %>%
  dplyr::left_join(d %>% dplyr::select(original_names, exp_groups[[1]][1]),
                   by = (c("Sample" = "original_names"))) %>%
  dplyr::mutate(NMR = as.numeric(NMR),
                FMR = as.numeric(FMR),
                Ncov5 = as.numeric(Ncov5),
                Nsig80 = as.numeric(Nsig80),
                Gini = as.numeric(Gini),
                dendrogram = as.numeric(dendrogram))

```

```{r QAQC_annotated}

QAQC_annotated <- dplyr::left_join(exp_metadata,
                                   QAQC_pass_fail,
                                   by = c("original_names" = "Sample")) %>%
  dplyr::right_join(QAQC, by = c("original_names" = "Sample"),
                   suffix = c("", "_data"))

QAQC_annotated$Any <- apply(QAQC_annotated,
                            MARGIN = 1,
                            FUN = function(x) ifelse(any(x == "FAIL", na.rm = T),"FAIL","PASS"))


outliers <- QAQC_failed$Sample

outlier_metadata <- exp_metadata[exp_metadata$original_names %in% outliers,]
metadata_outliers_removed <- exp_metadata[!exp_metadata$original_names %in% outliers,] %>%
  filter(.data[[params$technical_control]] == F)

```


## Metadata of samples identified as outliers

```{r table_metadata}
knitr::kable(outlier_metadata,
             caption = "Samples Removed") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  kableExtra::scroll_box(width = "100%", height = "480px")

QAQC_failed_kable <- outlier_metadata %>%
  dplyr::select(original_names,
                .data[[params$treatment_var]],
                .data[[params$dendro_color_by]]) %>%
  left_join(QAQC_failed, by = (c("original_names" = "Sample")))
```

## Sample groups summary - numbers of outliers in each group

```{r table_by_groups}
knitr::kable(QAQC_annotated %>%
               dplyr::group_by(.data[[params$treatment_var]],
                               .data[[params$dose]], Any) %>% # Could be better to somehow use exp_groups[[1]], but not sure how to get it working as expected
               tally() %>% dplyr::arrange(Any),
             caption = "Groups Summary") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  kableExtra::scroll_box(width = "100%", height = "480px")
```


## Pass/fail table for samples identified as outliers

```{r table_pass_fail}
knitr::kable(QAQC_failed_kable,
             caption = "Which samples were removed and why?") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```



## Pass/fail for each test, broken up by sample groups

```{r pass_fail_by_group}
QAQC_annotated %>%
  dplyr::group_by(dendrogram, group_dendrogram, NMR, FMR, Ncov5, Nsig80, Gini, Any, .data[[params$treatment_var]]) %>%
  tally() %>%
  knitr::kable(caption = "Pass/fail results by group") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```


### Vtree Summary

```{r vtree}

vtree(QAQC_annotated,
      "Any dendrogram group_dendrogram NMR FMR Ncov5 Nsig80 Gini", # Make "Any" first?
      summary = "NMR_data \nAverage Reads Mapped\n%mean% %leafonly% ",
      pngknit = FALSE) # This is not ideal - but the tmp files didn't work when rendering externally.

vtree(QAQC_annotated,
      "dendrogram group_dendrogram NMR FMR Ncov5 Nsig80 Gini",
      summary = "NMR_data \nAverage Reads Mapped\n%mean% %leafonly% ",
      pattern = T,
      pngknit = FALSE)

```

## Dendrogram and distance based filtering

A tree height cutoff of `r params$studywide_tree_height_cutoff` is used to cut the tree and separate outliers.

### Dendrogram, all samples, prefiltering

Technical control samples are colored differently.

```{r dendrogram_clustering}
message(paste0("The treatment variable is: ", params$treatment_var))


############################################################################
# Dendrogram: all
############################################################################
CairoPDF(file = file.path(paths$details, "dendrogram_prefiltering_all.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")


prefilt_dend_names <- colnames(cpm)
prefilt_dend_names <- prefilt_dend_names[order.dendrogram(dendro_before_all_samples)]

# Match the order of cpm column names in exp_metadata
exp_metadata_ordered <- exp_metadata[match(colnames(cpm), exp_metadata$original_names), ]

# Create prefilt_dend_labels, order based on the dendrogram
prefilt_dend_labels <- exp_metadata_ordered[, params$dendro_color_by]
prefilt_dend_labels <- prefilt_dend_labels[order.dendrogram(dendro_before_all_samples)]

if (params$platform == "TempO-Seq") {
colors_to_use <- ifelse(exp_metadata_ordered$technical_control == TRUE, "red", "black")
} else{
  colors_to_use <- rep.int(0,96)
}

# Order colors based on the dendrogram
ordered_colors <- colors_to_use[order.dendrogram(dendro_before_all_samples)]

# Assign colors to the dendrogram labels
labels_colors(dendro_before_all_samples) <- ordered_colors
labels_to_use <- paste(prefilt_dend_labels, prefilt_dend_names)

plot(dendro_before_all_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
invisible(dev.off())

# Repeat the plot so it appears in the HTML report
plot(dendro_before_all_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)

```




### Dendrogram, technical controls, prefiltering

Colored by `r params$dendro_color_by`.

```{r dendro_tech_before  }
############################################################################
# Technical Controls, Prefiltering
############################################################################
dendro_before_tech_ctrls <- 1 - cor(as.matrix(cpm %>% dplyr::select(all_of(tech_ctrl_names))),
                                           method = "spearman")

if (length(dendro_before_tech_ctrls) > 2) {
  exp_metadata_tech_ctrls <- exp_metadata %>% dplyr::filter(original_names %in% all_of(tech_ctrl_names))
  
  dendro_before_tech_ctrls <- sort_hclust(hclust(as.dist(dendro_before_tech_ctrls), method = "average"))
  
  dendro_before_tech_ctrls <- as.dendrogram(dendro_before_tech_ctrls)
  colors_to_use <- as.numeric(as.factor(exp_metadata_tech_ctrls[,params$dendro_color_by]))
  ordered_colors <- colors_to_use[order.dendrogram(dendro_before_tech_ctrls)]
  labels_colors(dendro_before_tech_ctrls) <- ordered_colors
  
  original_names <- exp_metadata_tech_ctrls[,"original_names"]
  original_names <- original_names[order.dendrogram(dendro_before_tech_ctrls)]
  
  labels_to_use <- exp_metadata_tech_ctrls[,params$dendro_color_by]
  labels_to_use <- labels_to_use[order.dendrogram(dendro_before_tech_ctrls)]
  labels_to_use <- paste(labels_to_use, original_names)
  
  CairoPDF(file = file.path(paths$details,
                            "dendrogram_prefiltering_tech_controls.pdf"),
           width = 14,
           height = 8.5,
           family = "Courier")
  
  par(cex = 0.4, mar = c(25, 4, 4, 2))
  print(plot(dendro_before_tech_ctrls %>%
               dendextend::set("labels", labels_to_use) %>%
               dendextend::set("labels_cex", 0.3),
             main = "log2 CPM",
             horiz = F)
  )
  abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
  invisible(dev.off())

  # Repeat the plot so it appears in the HTML report
  #par(cex = 0.4, mar = c(25, 4, 4, 2))
  print(plot(dendro_before_tech_ctrls %>%
               dendextend::set("labels", labels_to_use) %>%
               dendextend::set("labels_cex", 0.3),
             main = "log2 CPM",
             horiz = F)
  )
  abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
}

```

### Dendrogram, experimental samples, prefiltering

First colored by `r params$dendro_color_by` and then colored by dose.  

The dose colored dendrogram is hard-coded in this version and should be removed if your experiment does not involve dose-response (and therefore won't have a dose column in the metadata).  

```{r dendro_samples_before}
############################################################################
# Experimental Samples, Prefiltering
############################################################################

CairoPDF(file = file.path(paths$details,
                          "dendrogram_prefiltering_exp_samples.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendro_before_all_exp_samples <- 1-cor(as.matrix(cpm  %>% dplyr::select(all_of(sample_names))),
                                  method = "spearman")

dendro_before_all_exp_samples <- sort_hclust(hclust(as.dist(dendro_before_all_exp_samples), method = "average"))

dendro_before_all_exp_samples <- as.dendrogram(dendro_before_all_exp_samples)
colors_to_use <- as.numeric(as.factor(exp_metadata_exp_samples[,params$treatment_var]))
ordered_colors <- colors_to_use[order.dendrogram(dendro_before_all_exp_samples)]
labels_colors(dendro_before_all_exp_samples) <- ordered_colors

original_names <- exp_metadata_exp_samples[,"original_names"]
original_names <- original_names[order.dendrogram(dendro_before_all_exp_samples)]

labels_to_use <- exp_metadata_exp_samples[,params$dendro_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendro_before_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex = 0.2, mar = c(25, 4, 4, 2))
plot(dendro_before_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
invisible(dev.off())

# Repeat the plot so it appears in the HTML report

#par(cex = 0.2, mar = c(25, 4, 4, 2))
plot(dendro_before_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)

############################################################################
# Experimental Samples, Prefiltering, Colored by Dose
############################################################################

CairoPDF(file = file.path(paths$details,
                          "dendrogram_prefiltering_exp_samples_by_dose.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendro_before_all_exp_samples <- 1-cor(as.matrix(cpm  %>% dplyr::select(all_of(sample_names))),
                                  method = "spearman")

exp_metadata_exp_samples <- exp_metadata %>% dplyr::filter(original_names %in% all_of(sample_names))

dendro_before_all_exp_samples <- sort_hclust(hclust(as.dist(dendro_before_all_exp_samples), method = "average"))

dendro_before_all_exp_samples <- as.dendrogram(dendro_before_all_exp_samples)
colors_to_use <- as.numeric(as.factor(exp_metadata_exp_samples[,params$dendro_color_by]))
ordered_colors <- colors_to_use[order.dendrogram(dendro_before_all_exp_samples)]
labels_colors(dendro_before_all_exp_samples) <- ordered_colors

original_names <- exp_metadata_exp_samples[,"original_names"]
original_names <- original_names[order.dendrogram(dendro_before_all_exp_samples)]

labels_to_use <- exp_metadata_exp_samples[,params$dendro_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendro_before_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex = 0.2, mar = c(25, 4, 4, 2))
plot(dendro_before_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
invisible(dev.off())

# Repeat the plot so it appears in the HTML report
#par(cex = 0.2, mar = c(25, 4, 4, 2))
plot(dendro_before_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)

```

## Dendrogram filtering within groups {.tabset}

```{r display-dendrograms, results='asis', echo=FALSE}
# Display the saved dendrograms

for (facet in names(dendrograms)) {
  cat("### ", facet, "  \n\n")
  dendro_facet <- dendrograms[[facet]]

  # Plot dendrogram
  par(cex = 0.75, mar = c(25, 4, 4, 2))
  plot(dendro_facet %>%
         dendextend::set("labels_cex", 1),
       main = "log2 CPM",
       horiz = F)
  abline(h = params$group_tree_height_cutoff, col = "red", lwd = 2)
  cat('\n\n')
}
```



# Correlations 
## Within Group Correlations {.tabset}

These plots show correlations within each experimental grouping.  

Click on the tabs below to see the robust PCA and Pearson correlations for all samples within a group.  

NOTE the within-group correlations are all wrapped up with the group dendrograms. I need to separate this out.
```{r, fig.width = 11, fig.height = 10, results='asis'}
### To view correlations for groups of interest...



for (i in seq_along(facets)) {
  cat("### ", facets[i], "  \n\n")
  samples_in_facet <- exp_metadata_exp_samples[exp_metadata_exp_samples[params$treatment_var] == facets[i],
                                            "original_names"]
  if (length(samples_in_facet) < 2) { next }
  cpm_subset <- as.matrix(cpm %>% dplyr::select(all_of(samples_in_facet)))
  pca_subset <- rrcov::PcaGrid(t(cpm_subset))
  #biplot <- rrcov::biplot(pca_subset)
  correlations <- cor(cpm_subset, method = "pearson")
  correlation_df <- exp_metadata %>%
    filter(original_names %in% colnames(correlations))

  

### Make correlation robust PCA plots
  row.names(correlation_df) <- correlation_df$original_names
  correlation_df <- correlation_df[colnames(correlations),]
  correlation_df <- as.data.frame(correlation_df[unlist(exp_groups[[1]][1])])
  group_heatmap <- pheatmap(correlations,
                            annotation_col = correlation_df,
                            display_numbers = T,
                            cutree_cols = 2,
                            cutree_rows = 2)
 
  plot(pca_subset)
  print(group_heatmap)
  correlations <- as.data.frame(correlations)
  correlations$original_names <- row.names(correlations)
  cor_distribution <- correlations %>%
    mutate(mean = rowMeans(across(where(is.numeric)))) %>%
    dplyr::select(mean, original_names) %>%
    mutate(facet = facets[i])
  cor_list[[i]] <- cor_distribution
  cat('  \n\n')
}
```




## Distribution of correlations

### Mean of per-sample correlations with every other sample in the study

In other words, for each sample, what is its mean correlation with **every other sample in the study**?

Sometimes it might be necessary to zoom in to see the required level of granularity on these plots. Click and drag a box around the region you would like to view in more detail.

```{r,  fig.width = 9, fig.height = 10}
cor_df1 <- as.data.frame(ref_correlations_samples)
cor_df1$original_names <- row.names(cor_df1)
cor_df2 <- exp_metadata_exp_samples[c(params$treatment_var,"original_names")]
# STUDY WIDE CORRELATION MEANS
cor_distribution_all <- left_join(cor_df1, cor_df2) %>%
    mutate(mean = rowMeans(across(where(is.numeric)))) %>%
    dplyr::select(mean, original_names, .data[[params$treatment_var]])
cor_plot <- ggplot(cor_distribution_all, aes(.data[[params$treatment_var]], mean)) +
  geom_boxplot(outlier.shape = NA, outlier.color = NA) +
  geom_jitter(size = 0.5) +
  theme(axis.text = element_text(angle = 90))
ggplotly(cor_plot)
# Ok, there's a bug that prevents outliers from being hidden, but whatever.
# https://github.com/plotly/plotly.R/issues/1114
```

### Mean of per-sample correlations with every other sample in its corresponding group

In other words, for each sample, what is its mean correlation with every sample **within in its experimental grouping**?

```{r,  fig.width = 9, fig.height = 10}
# MEANS BY CHEMICAL
cor_means_by_chem <- data.table::rbindlist(cor_list)
cor_plot_2 <- ggplot(cor_means_by_chem, aes(facet, mean)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(size = 0.5) +
  theme(axis.text = element_text(angle = 90))
ggplotly(cor_plot_2)
```


# Compose tables


# Tables and plots

This section shows several tables of the outlier data.  




## Potential covariates

This examines correlations between the QC metrics calculated and any factors in the experimental design.  

Please note that in these pairwise plots, some relationships are meaningless (e.g., dose vs dose). This is meant to explore trends that may not otherwise be apparent.  

```{r possible_covariates, fig.height = 12, fig.width = 12}

if (!is.na(params$batch_var)) {
QAQC_metadata_subset <- QAQC_annotated %>%
  dplyr::select(unlist(exp_groups), .data[[params$batch_var]],
                NMR_data, FMR_data, Ncov5_data, Nsig80_data, Gini_data)
  QAQC_metadata_subset[,params$batch_var] <- factor(QAQC_metadata_subset[,params$batch_var])
} else {
    QAQC_metadata_subset <- QAQC_annotated %>%
    dplyr::select(unlist(exp_groups),
                  NMR_data, FMR_data, Ncov5_data, Nsig80_data, Gini_data)
}

QAQC_metadata_subset %>%
    summarise_all(~length(unique(.))) # Just info. Output not used
    #summarise_each(levels(as.factor(.))) %>% tally()

potential_covariates <- QAQC_metadata_subset %>%
  dplyr::mutate_all(as.factor) %>%
  purrr::map(levels) %>%
  purrr::map(length)


covariate_names <- names(potential_covariates[potential_covariates < 24])

# Need a generic way to look for dose column...
#QAQC_metadata_subset$dose <- factor(log(QAQC_metadata_subset$dose+1))

if (length(exp_groups) > 1 & !is.na(params$batch_var)) {
  for (i in seq_along(exp_groups)[1:length(exp_groups)]) {
    # Drop groups that have high numbers of possible values
    covariate_cols <- unlist(exp_groups[[i]])
    for (subgroup in covariate_cols) {
      cardinality <- length(levels(factor(QAQC_metadata_subset[,subgroup])))
      if (cardinality > 24) {
        covariate_cols <- covariate_cols[!covariate_cols %in% subgroup]
      }
    }
    if (length(covariate_cols) < 1) {next}
    p <- ggpairs(QAQC_metadata_subset,
                 cardinality_threshold = 24,
                 columns = c(covariate_cols,
                           "NMR_data", "FMR_data", "Ncov5_data", "Nsig80_data", "Gini_data"),
                 ggplot2::aes(colour = .data[[params$batch_var]]))
    print(p)
  }
} else {
  if (length(exp_groups) <= 1 & !is.na(params$batch_var)) {
  p <- ggpairs(QAQC_metadata_subset,
                 cardinality_threshold = 24,
                 columns = c(unlist(exp_groups),
                           "NMR_data", "FMR_data", "Ncov5_data", "Nsig80_data", "Gini_data"),
                 ggplot2::aes(colour = .data[[params$batch_var]]))
  print(p)
} else {
  if (is.na(params$batch_var)) {
  p <- ggpairs(QAQC_metadata_subset,
                 cardinality_threshold = 24,
                 columns = c(unlist(exp_groups),
                           "NMR_data", "FMR_data", "Ncov5_data", "Nsig80_data", "Gini_data"))
  print(p)
  }
}
}

```


## Plate position effects {.tabset}

Click on the tabs below to view the plate layout for the experiment (if any was provided) and the corresponding quality metrics according to position.

```{r is-there-plate-info, echo = F, warning = F}
are_there_plates <- any(grepl("column", colnames(QAQC_annotated), ignore.case = T))

if (!is.na(params$batch_var)) {
  batch_length <- length(unique(QAQC_annotated[, params$batch_var]))
} else{
  batch_length <- 1
}
```

```{r plate_pos, eval = are_there_plates}
colnum <- which(grepl("column", colnames(QAQC_annotated), ignore.case = T))[1]
rownum <- which(grepl("row", colnames(QAQC_annotated), ignore.case = T))[1]
colname <- names(QAQC_annotated[colnum])
rowname <- names(QAQC_annotated[rownum])
plate_plot <- ggplot(QAQC_annotated, aes(x = factor(.data[[colname]]),
                                         y = factor(.data[[rowname]], levels = rev(levels(factor(.data[[rowname]])))),
                                         name = original_names,
                                         treat = .data[[params$treatment_var]],
                                         dose = .data[[params$dose]])) +
  theme(legend.position = "right",
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        panel.spacing = unit(2, "lines")) +
  scale_x_discrete(position = "top")

if (!is.na(params$batch_var)) {
  plate_plot <- plate_plot + facet_wrap2(
    ~ .data[[params$batch_var]], 
    scales = "free", axes = "all", remove_labels = FALSE, 
    ncol = 2)
} else {
  plate_plot <- plate_plot + theme(
    plot.margin = margin(0, 0, 0, 0, "cm"),
    legend.text = element_text(size = 8)
  )
}

```


```{r}
custom_fig_height <- ifelse(test = batch_length > 1, yes = batch_length, no = 2.75)

# Set plot width to narrow for single plate, and wider for multiple plates to accomodate two column facet wrap
custom_fig_width <- ifelse(test = batch_length > 1, yes = batch_length, no = 4)

```

### Number of Mapped Reads

```{r fig.height = as.numeric(custom_fig_height), fig.width = custom_fig_width, eval = are_there_plates}
(plate_plot +
  geom_point(mapping = aes(color = NMR_data, val = NMR_data), data = QAQC_annotated, size = 3) +
  ggtitle("Number of mapped reads"))  %>%
  ggplotly(tooltip = c("name", "treat", "dose", "val"))
```

### Fraction of Mapped Reads

```{r fig.height = as.numeric(custom_fig_height), fig.width = custom_fig_width, eval = are_there_plates}
(plate_plot +
  geom_point(mapping = aes(color = FMR_data, val = FMR_data), data = QAQC_annotated, size = 3) +
  ggtitle("Fraction of mapped reads")) %>%
  ggplotly(tooltip = c("name","treat","dose","val"))
```

### Nsig80

```{r fig.height = as.numeric(custom_fig_height), fig.width = custom_fig_width, eval = are_there_plates}
(plate_plot +
  geom_point(mapping = aes(color = Nsig80_data, val = Nsig80_data), data = QAQC_annotated, size = 3) +
  ggtitle("Nsig80")) %>%
  ggplotly(tooltip = c("name", "treat", "dose", "val"))
```

### Ncov5

```{r fig.height = as.numeric(custom_fig_height), fig.width = custom_fig_width, eval = are_there_plates}
(plate_plot +
  geom_point(mapping = aes(color = Ncov5_data, val = Ncov5_data), data = QAQC_annotated, size = 3) +
  ggtitle("Ncov5")) %>%
  ggplotly(tooltip = c("name", "treat", "dose", "val"))
```

### Gini

```{r fig.height = as.numeric(custom_fig_height), fig.width = custom_fig_width, eval = are_there_plates}
(plate_plot +
  geom_point(mapping = aes(color = Gini_data, val = Gini_data), data = QAQC_annotated, size = 3) +
  ggtitle("Gini")) %>%
  ggplotly(tooltip = c("name", "treat", "dose", "val"))
```

### Any samples which failed

```{r fig.height = as.numeric(custom_fig_height), fig.width = custom_fig_width, eval = are_there_plates}
(plate_plot +
  geom_tile(mapping = aes(fill = log(.data[[params$dose]] + 1)),
            data = QAQC_annotated) +   
  scale_fill_gradient(low = "grey", high = "black") +
  geom_point(mapping = aes(color = Any, val = Any), data = QAQC_annotated, size = 3) +
  ggtitle("Any samples failed")) %>%
  ggplotly(tooltip = c("name", "treat", "dose", "val"))
```



## Write tables to disk

```{r write_output}
outlier_metadata_annotated <- dplyr::left_join(outlier_metadata,
                                               QAQC_pass_fail,
                                               by = c("original_names" = "Sample"))
write.table(outlier_metadata_annotated,
            file.path(paths$details, "samples_removed.txt"),
            sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

write.table(QAQC_annotated,
            file.path(paths$details, "QC_per_sample.txt"),
            sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

write.table(metadata_outliers_removed,
            file.path(paths$qc, "metadata.QC_applied.txt"),
            sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

count_data_filtered <- count_data %>% dplyr::select(-all_of(outliers))

```


There are `r ncol(count_data_filtered)` samples remaining in the study after sample removal.

## Dendrogram (after filtering)

### Dendrogram, all samples, postfiltering

```{r dendrogram_all_after}
############################################################################
# Dendrogram: all, after filtering
############################################################################

CairoPDF(file = file.path(paths$details, "dendrogram_postfiltering_all.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendro_after_all_samples <- 1 - cor(as.matrix(cpm %>% dplyr::select(-all_of(outliers))),
                                  method = "spearman")

dendro_after_all_samples <- sort_hclust(hclust(as.dist(dendro_after_all_samples), method = "average"))

dendro_after_all_samples <- as.dendrogram(dendro_after_all_samples)
colors_to_use <- as.numeric(as.factor(exp_metadata[,params$technical_control]))
ordered_colors <- colors_to_use[order.dendrogram(dendro_after_all_samples)]
labels_colors(dendro_after_all_samples) <- ordered_colors

original_names <- exp_metadata[,"original_names"]
original_names <- original_names[order.dendrogram(dendro_after_all_samples)]

labels_to_use <- exp_metadata[,params$dendro_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendro_after_all_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex = 0.15, mar = c(25, 4, 4, 2))
plot(dendro_after_all_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
invisible(dev.off())

# Repeat plot so it appears in the HTML report
plot(dendro_after_all_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
```

### Dendrogram, technical control samples, postfiltering

```{r dendrogram_technical_after}
############################################################################
# Technical Controls, Postfiltering
############################################################################
dendro_after_tech_ctrls <- 1 - cor(as.matrix(cpm %>%
                                            dplyr::select(all_of(tech_ctrl_names)) %>%
                                            dplyr::select(-all_of(outliers[outliers %in% tech_ctrl_names]))),
                                method = "spearman")
if (length(dendro_after_tech_ctrls) > 2) {
  exp_metadata_tech_ctrls <- exp_metadata %>% dplyr::filter(original_names %in% all_of(tech_ctrl_names))
  
  dendro_after_tech_ctrls <- sort_hclust(hclust(as.dist(dendro_after_tech_ctrls), method = "average"))
  
  dendro_after_tech_ctrls <- as.dendrogram(dendro_after_tech_ctrls)
  colors_to_use <- as.numeric(as.factor(exp_metadata_tech_ctrls[,params$dendro_color_by]))
  ordered_colors <- colors_to_use[order.dendrogram(dendro_after_tech_ctrls)]
  labels_colors(dendro_after_tech_ctrls) <- ordered_colors
  
  original_names <- exp_metadata_tech_ctrls[,"original_names"]
  original_names <- original_names[order.dendrogram(dendro_after_tech_ctrls)]
  
  labels_to_use <- exp_metadata_tech_ctrls[,params$dendro_color_by]
  labels_to_use <- labels_to_use[order.dendrogram(dendro_after_tech_ctrls)]
  labels_to_use <- paste(labels_to_use, original_names)
  
  CairoPDF(file = file.path(paths$details,
                            "dendrogram_postfiltering_tech_controls.pdf"),
           width = 14,
           height = 8.5,
           family = "Courier")
  par(cex = 0.4, mar = c(25, 4, 4, 2))
  plot(dendro_after_tech_ctrls %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
       main = "log2 CPM",
       horiz = F)
  abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
  invisible(dev.off())

  # Repeat plot so it appears in the HTML report
  plot(dendro_after_tech_ctrls %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
       main = "log2 CPM",
       horiz = F)
  abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
}
```

### Dendrogram, experimental samples, postfiltering

```{r dendrogram_exp_after}
############################################################################
# Experimental Samples, Postfiltering
############################################################################

CairoPDF(file = file.path(paths$details,
                          "dendrogram_prefiltering_exp_samples.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendro_after_all_exp_samples <- 1-cor(as.matrix(cpm %>%
                                            dplyr::select(all_of(sample_names)) %>%
                                            dplyr::select(-all_of(outliers[outliers %in% sample_names]))),
                                  method = "spearman")

exp_metadata_exp_samples <- exp_metadata %>% dplyr::filter(original_names %in% all_of(sample_names))

dendro_after_all_exp_samples <- sort_hclust(hclust(as.dist(dendro_after_all_exp_samples), method = "average"))

dendro_after_all_exp_samples <- as.dendrogram(dendro_after_all_exp_samples)
colors_to_use <- as.numeric(as.factor(exp_metadata_exp_samples[,unlist(exp_groups)[1]]))
ordered_colors <- colors_to_use[order.dendrogram(dendro_after_all_exp_samples)]
labels_colors(dendro_after_all_exp_samples) <- ordered_colors

original_names <- exp_metadata_exp_samples[,"original_names"]
original_names <- original_names[order.dendrogram(dendro_after_all_exp_samples)]

labels_to_use <- exp_metadata_exp_samples[,params$dendro_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendro_after_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex = 0.2, mar = c(25, 4, 4, 2))
plot(dendro_after_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
invisible(dev.off())

# Repeat the plot so it appears in the HTML report
plot(dendro_after_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)

```

### Dendrogram, experimental samples, postfiltering, colored by dose

```{r dendrogram_exp_post_dose}
############################################################################
# Experimental Samples, Postfiltering, Colored by Dose
############################################################################

CairoPDF(file = file.path(paths$details,
                          "dendrogram_prefiltering_exp_samples_by_dose.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendro_after_all_exp_samples <- 1-cor(as.matrix(cpm %>%
                                                 dplyr::select(all_of(sample_names)) %>%
                                                 dplyr::select(-all_of(outliers[outliers %in% sample_names]))),
                                     method = "spearman")

exp_metadata_exp_samples <- exp_metadata %>% dplyr::filter(original_names %in% all_of(sample_names))

dendro_after_all_exp_samples <- sort_hclust(hclust(as.dist(dendro_after_all_exp_samples), method = "average"))

dendro_after_all_exp_samples <- as.dendrogram(dendro_after_all_exp_samples)
colors_to_use <- as.numeric(as.factor(exp_metadata_exp_samples[,params$dendro_color_by]))
ordered_colors <- colors_to_use[order.dendrogram(dendro_after_all_exp_samples)]
labels_colors(dendro_after_all_exp_samples) <- ordered_colors

original_names <- exp_metadata_exp_samples[,"original_names"]
original_names <- original_names[order.dendrogram(dendro_after_all_exp_samples)]

labels_to_use <- exp_metadata_exp_samples[,params$dendro_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendro_after_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex = 0.2, mar = c(25, 4, 4, 2))
plot(dendro_after_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
invisible(dev.off())

# Repeat the plot so it appears in the HTML report
plot(dendro_after_all_exp_samples %>%
       dendextend::set("labels", labels_to_use) %>%
       dendextend::set("labels_cex", 0.3),
     main = "log2 CPM",
     horiz = F)
abline(h = params$studywide_tree_height_cutoff, col = "red", lwd = 2)
```


## Plots of QC data metrics

### Batch

```{r plot_batch_effects, eval = !is.na(params$batch_var), fig.height = as.numeric(custom_fig_height)*1.5}

plot_batches <- ggplot(QAQC_annotated, aes(x = .data[[params$treatment_var]], color = .data[[params$treatment_var]])) +
  facet_wrap(paste0("~",params$batch_var), scales = "free_y", labeller = labeller(
    .cols = add_spaces,
    .default = label_wrap_gen(100)), ncol = 1) +
  theme(legend.position = "none") + xlab("Batch") +
  theme(axis.text.x = element_text(angle = 90)) +
  coord_flip()

plot_batches + geom_boxplot(aes(y = Gini_data)) + ggtitle("Gini")
plot_batches + geom_boxplot(aes(y = NMR_data)) + ggtitle("Number of Mapped Reads") 
plot_batches + geom_boxplot(aes(y = FMR_data)) + ggtitle("Fraction of Mapped Reads")
plot_batches + geom_boxplot(aes(y = Ncov5_data)) + ggtitle("Proportion of active probes (% probes with >5 mapped reads)")
plot_batches + geom_boxplot(aes(y = Nsig80_data)) + ggtitle("Proportion of probes required to account for 80% of signal")

```

### Dose effects

```{r plot_chemical_differences, eval=!is.na(params$dose), fig.height = as.numeric(custom_fig_height)*1.5}
# It would make sense to use params$dose instead of dose here - but ensym() doesn't want to evaluate it properly? Error: arg must be of length 1 - maybe because it's part of a list? Early on, dose <- params$dose sets it to a character vector, maybe the class is interpreted differently by ensym().
plot_dose_effect <- ggplot(QAQC_annotated, aes(x = factor(.data[[params$dose]]),
                                               color = factor(.data[[params$dose]]))) +
  facet_wrap(paste0("~", params$treatment_var), scales = "free") +
  theme(legend.position = "none") + xlab("Dose") + # labs(color = dose) +
  theme(axis.text.x = element_text(angle = 90))

plot_dose_effect + geom_boxplot(aes(y = Gini_data)) + ggtitle("Gini")
plot_dose_effect + geom_boxplot(aes(y = NMR_data)) + ggtitle("Number of Mapped Reads") + scale_y_continuous(labels = scales::scientific)
plot_dose_effect + geom_boxplot(aes(y = FMR_data)) + ggtitle("Fraction of Mapped Reads") 
plot_dose_effect + geom_boxplot(aes(y = Ncov5_data)) + ggtitle("Proportion of active probes (% probes with >5 mapped reads)")
plot_dose_effect + geom_boxplot(aes(y = Nsig80_data)) + ggtitle("Proportion of probes required to account for 80% of signal")
```


# References {-}

If these methods were used in your study, please cite the following papers as appropriate:  



<div id="refs"></div>




# Appendix (additional plots)

## GC content

Summary of GC content of probes (TempO-Seq only)
```{r plot-gc, eval=params$platform == "TempO-Seq"}

# Calculate the GC content for each probe, add this value as a column
manifest <- manifest %>% mutate(gc_content=calculate_gc(Probe_Sequence))

count_data_gc <- dplyr::left_join(tibble::rownames_to_column(count_data),
                                  manifest,
                                  by = c("rowname" = "Probe_Name")) %>%
  tidyr::pivot_longer(all_of(c(exp_metadata$original_names)),
                      names_to = "sample", values_to = "count") %>%
  dplyr::mutate(GC_corrected_count = count/gc_content)
ggplot(count_data_gc,aes(x=GC_corrected_count,colour=sample)) +
  geom_density() +
  scale_x_log10() +
  theme(legend.position = "none")

gc_summary <- count_data_gc %>%
  group_by(sample) %>%
  summarise(median_gc = median(GC_corrected_count), mean_gc = mean(GC_corrected_count))

gc_summary_long <- gc_summary %>%
  pivot_longer(cols=c("mean_gc","median_gc"))

ggplot(gc_summary_long,
       aes(x=name, y=value)) +
  geom_jitter(alpha = 0.1) +
  geom_violin(fill = "transparent") +
  facet_wrap(name~., scales = "free")

gc_summary %>%
  kable(caption = "Summary GC statistics") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```


## Zero count heatmap

Heatmap showing presence of zeroes (black) in the data.

```{r zero-heatmap, fig.width = 11, fig.height = 10}


if(nrow(count_data) > 3000){
  random_indices <- sample(nrow(count_data), 2500)
  count_data_random <- count_data[random_indices, ]
  count_data_is0 <- ((count_data_random==0)*1)
} else{
  count_data_is0 <- ((count_data==0)*1)
}

annotation_col <- exp_metadata %>%
  dplyr::select(c(as.vector(unlist(params$exp_groups)),"original_names")) %>%
  tibble::column_to_rownames("original_names")

pheatmap(count_data_is0,
         color = c("white", "black"),
         annotation_col = annotation_col,
         treeheight_col = 30,
         treeheight_row = 0,
         show_rownames=F,
         legend=F)

```


```{r, child=file.path(paths$projectdir,'Rmd','session_info.Rmd')}
```


<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
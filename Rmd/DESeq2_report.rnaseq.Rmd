---
params:
  projectdir: !r here::here() # Can hard code if for some reason you need that
  project_name: "test data"        # Change depending on your project name
  species: "mouse"                 # one of human, mouse, rat, hamster
  design: "group"                # single experimental group of interest; entries in this column must match the contrast names.
  intgroup: ["group"]            # experimental group of interest plus covariates; can be more than one
  batch_var: !r NA                 # "Batch" To remove batch effects for PCA/Heatmaps visualiziations
  platform: "TempO-Seq"            # RNA-Seq or TempO-Seq
  group_facet: "chemical"       #null # If you have many different experimental groups, you may subset the report by specifying a column in the metadata to filter groups, and then setting the group of interest in group_filter
  group_filter:  "BitA"       # null # Which group will this report be done on?
  sortcol: "dose"                # Optionally, a column by which to sort the contrasts
  dose: "dose"                   # Explictly define if there is a dose column in the experiment. Note: this *can* be different from the sortcol, which is why we include both.
  strict_contrasts: FALSE         # Use both columns (exp, cont) of contrasts file to limit what is included in the report
  exclude_samples: !r NA  # Optionally, a vector of sample names to exclude from the analysis
  exclude_groups: !r NA # Optionally, a vector of groups to exclude from the analysis. By default this is assumed to be in the column specified by params$design.
  include_only_column:  !r NA # Restrict analysis to group(s) in the column listed here based on params$include_only_group.
  include_only_group:  !r NA # Restrict analysis to this/these group(s) within the column listed in params$include_only_column
  use_cached_RData: FALSE # If possible, load the saved RData for dds object and gene IDs
  cpus: 12 # Set to a lower number (e.g., 2 to 4) if you aren't working in a server environment
  run_pathway_analysis: TRUE # Optionally disable pathway analysis if not available for your organism
  wikipathways_directory: "~/shared/dbs/wikipathways"
  biospyder_dbs: "~/shared/dbs/biospyder/"
  biospyder_manifest_file: "190603 Mouse Whole Transcriptome 1.1 Manifest.txt"
  nBestFeatures: 20 # The number of best features to make plots of their counts
  nBest: 100 # Number of features to include in table and limiting PCA/clustering analysis
  nHeatmap: 50 # Number of most variable genes for heatmap
  nHeatmapDEGs: 50 # Number of DEGs for heatmap
title: "`r paste('Transcriptome analysis:', gsub(pattern = '_', replacement = ' ', x = params$project_name))`"
subtitle: "`r paste(params$platform, 'analysis', ifelse(!is.na(params$group_filter), paste('for', paste(params$group_filter, collapse=' and ')), ''))`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: spacelab           # flatly spacelab sandstone cerulean
    code_download: true
bibliography: "`r file.path(params$projectdir, 'Rmd/references.bib')`"
author: "Your Name"
---

***

# Revision History

**This version**  
  
*Current version: 1*  
Date report generated: `r format(Sys.time(), '%d %B, %Y')`  
Report prepared for: Name  
Purpose of report:  

* Exercise to analyze RNA-Seq data  

**Previous revisions**  

N/A  

***

# Code setup, Data Loading, and DESeq2 Code

This report is meant to help explore DESeq2 results and was generated using RMarkdown. The structure of this document extends the DESeq2 regionReport RMarkdown [@collado2015regionreport][@regionreport2017]. This section contains the code for setting up the rest of the report.  

## Load libraries

```{r docSetup, warning = FALSE, message = FALSE}
## Define paths
paths <- list()
# Other important system paths to specify in config
paths$wikipathways <- params$wikipathways_directory
# For project structure
paths$root <- params$projectdir
paths$data <- file.path(paths$root, "data")
paths$processed <- file.path(paths$data, "processed")
paths$metadata <- file.path(paths$data, "metadata")
if (is.na(params$group_facet)) {
  paths$DEG_output <- file.path(paths$root, "analysis", "DEG_lists")
  paths$pathway_analysis <- file.path(paths$root, "analysis", "pathway_analysis")
} else {
  paths$DEG_output <- file.path(paths$root, "analysis",
                                "DEG_lists", params$group_filter)
  paths$pathway_analysis <- file.path(paths$root, "analysis",
                                      "pathway_analysis", params$group_filter)
}
paths$BMD_output <- file.path(paths$root,  "analysis", "BMD_and_biomarker_files")

paths$RData <- file.path(paths$DEG_output, "RData")
paths$ODAFdir <- file.path(paths$DEG_output, "R-ODAF")

# Create directories if required
if (!dir.exists(paths$ODAFdir)) {dir.create(paths$ODAFdir, recursive = TRUE)}
if (!dir.exists(paths$DEG_output)) {dir.create(paths$DEG_output, recursive = TRUE)}
if (!dir.exists(paths$BMD_output)) {dir.create(paths$BMD_output, recursive = TRUE)}
if (!dir.exists(paths$pathway_analysis)) {dir.create(paths$pathway_analysis, recursive = TRUE)}
if (!dir.exists(paths$RData)) {dir.create(paths$RData, recursive = TRUE)}

## knitrBoostrap and device chunk options
# Set so that long lines in R will be wrapped:
knitr::opts_chunk$set(bootstrap.show.code = FALSE,
                      bootstrap.panel = TRUE,
                      cache = FALSE)
#knitr::tidy.opts = list(width.cutoff = 60), tidy = TRUE, crop = NULL # Use for PDFs
knitr::opts_knit$set(root.dir = paths$root) # Do we need this?

pathway_analysis <- file.path(paths$root, "Rmd/Pathway_analysis.Rmd")
```

```{r setup, warning = FALSE, message = FALSE}
#### Record start time
startTime <- Sys.time()

#### Load Libraries
# General purpose
# library('conflicted')
library('knitr')
library('kableExtra')
library('tidyverse')
library('magrittr')
library('ggplot2')
library('DT')
library('data.table')
library('pheatmap')
library('lattice')
library('tidytext')
library('openxlsx')
library('RColorBrewer')
library('viridis')
library('sessioninfo')
library('plotly')
library('dendextend')
library('gtools')
library('ggridges')
library('crosstalk')
library('crosstool')
#library('manipulateWidget')
#library('RMariaDB')

# Bioinformatics-specific
library('DESeq2')
library('limma')
library('edgeR')
library('enrichplot')
library('rWikiPathways')
library('BiocParallel')
library('clusterProfiler')
library('biomaRt')
library('AnnotationHub')
library('vsn')

# Load genome, depends on species
# To add: Zebrafish, Folsomia candida, others?
species <- params$species
if (species == "human") {
  # Human:
  library('org.Hs.eg.db')
  orgdb <- "org.Hs.eg.db"
  species_sci <- "Homo sapiens"
  wiki <- params$wikipathways_filename
  ensembl_species <- "hsapiens_gene_ensembl"
  species_gene_symbol <- "external_gene_name"
  kegg_organism <- "hsa"
  temposeq_manifest <- params$biospyder_manifest_file #"191113_Human_S1500_Surrogate_2.0_Manifest.csv"
  # options:
  # "191113_Human_S1500_Surrogate_2.0_Manifest.csv"
  # "181019_Human_S1500_Surrogate_1.2_Manifest.txt"
  # "191004_Human_Whole_Transcriptome_2.0_Manifest.txt"
} else {
  if (species == "mouse") {
    # Mouse:
    library('org.Mm.eg.db')
    orgdb <- "org.Mm.eg.db"
    species_sci <- "Mus musculus"
    wiki <- params$wikipathways_filename
    ensembl_species <- "mmusculus_gene_ensembl"
    species_gene_symbol <- "mgi_symbol"
    kegg_organism <- "mmu"
    temposeq_manifest <- params$biospyder_manifest_file  # "181130 Mouse S1500+ Surrogate 1.2 Manifest.txt" # or 190603 Mouse Whole Transcriptome 1.1 Manifest.xlsx
} else {
  if (species == "rat") {
    # Rat: 
    library('org.Rn.eg.db')
    orgdb <- "org.Rn.eg.db"
    species_sci <- "Rattus norvegicus"
    wiki <- params$wikipathways_filename
    ensembl_species <- "rnorvegicus_gene_ensembl"
    species_gene_symbol <- "rgd_symbol"
    kegg_organism <- "rno"
    temposeq_manifest <- params$biospyder_manifest_file # "190809 Rat Whole Transcriptome 1.0 Manifest.xlsx"
} else {
  if (species == "hamster") {
    # Golden hamster:
    OrgDb.Ma <- query(AnnotationHub(), c("OrgDb", "Mesocricetus auratus"))[[1]]
    orgdb <- "OrgDb.Ma"
    species_sci <- "Mesocricetus auratus"
    ensembl_species <- "mauratus_gene_ensembl"
    species_gene_symbol <- "external_gene_name"
} else {
  message("No species picked!")
}
}
}
}

# Options
options(java.parameters = "-Xmx10000m")
theme_set(theme_bw())
```

The code above (not shown by default) loads the relevant R packages required for analysis.

## Specify parameters

```{r setup_code, warning = FALSE, message = FALSE, collapse = TRUE}
################################################################################
################################################################################
# PARAMETERS - should be set by YAML header.
################################################################################
################################################################################

# Various plotting and display options
nBestFeatures <- params$nBestFeatures
nBest <- params$nBest
nHeatmap <- params$nHeatmap
nHeatmapDEGs <- 50

# Set analysis ID. This ID will be used as prefix for the output files
# Normally, as follows: year - project_name - group_filter
if (is.na(params$group_filter)) {
  analysisID <- paste(format(Sys.time(), '%Y'), params$project_name, sep = "_")
} else {
  analysisID <- paste(format(Sys.time(), '%Y'),
                      params$project_name,
                      paste(params$group_filter, collapse = "_"),
                      sep = "_")
}
# Specify used platform/technology for data generation:
Platform <- params$platform # Should be one of "RNA-Seq" or "TempO-Seq"
NORM_TYPE <- paste0(analysisID, "_DESeq2_", Platform)
# Misc parameters
digits = 2 # For rounding numbers

################################################################################
################################################################################
#### FILES TO LOAD
################################################################################
################################################################################
# A. Tab delimited file with merged RSEM.genes.results files:
if (Platform == "TempO-Seq") {
  SampleDataFile <- file.path(paths$processed, "count_table.tsv")
  sampledata_sep = ","
} else {
  SampleDataFile <- file.path(paths$processed, "genes.data.tsv")
  sampledata_sep = "\t"
}
  
# B. Tab delimited sample information file with at least 2 columns:
  # 1. sample names identical to the column names of sampleData
  # 2. compound/group/whatever (needs to identify to which experimental group the sample belongs)
SampleKeyFile <- file.path(paths$metadata, "metadata.QC_applied.txt")
# C. Tab delimited file of comparisons (contrasts) to test 
# Group of interest in the left column, control for comparison in the right column
ContrastsFile <- file.path(paths$metadata, "contrasts.txt")

# Specify which groups need to be compared 
contrasts <- read.delim(ContrastsFile, stringsAsFactors = FALSE, sep = "\t", header = FALSE,  quote = "\"")
DESIGN <- params$design	# Column name which defines the groups to be compared
intgroup <- params$intgroup # "Interesting groups" - experimental group/covariates
```

The code above (not shown by default) specifies user preferences and data locations.

## Load data

```{r 'load_data', collapse = TRUE, warning = FALSE, message = FALSE}
# Load input files
message(paste("loading data from ", SampleDataFile))
sampleData <- read.delim(SampleDataFile,
                         sep = sampledata_sep,
                         stringsAsFactors = FALSE,
                         header = TRUE, 
                         quote = "\"",
                         row.names = 1,
                         check.names = FALSE)
message(paste("loading metadata from ", SampleKeyFile))
DESeqDesign <- read.delim(SampleKeyFile,
                          stringsAsFactors = FALSE,
                          sep = "\t",
                          header = TRUE,
                          quote = "\"",
                          row.names = 1) # Pick column that is used in ID; might be more appropriate to change this!
DESeqDesign$original_names <- rownames(DESeqDesign)
DESeqDesignAsRead <- DESeqDesign

# Parameter-specified exclusions
# Conditionally exclude contrasts and metadata that should be filtered
# 1. Filter by group filter - useful for selecting one treatment at a time. params$group_filter
# 2. Filter manually - useful for removing irrelevant control groups (e.g. reference RNA). params$exclude_groups
# Note that these should only be run if the respective variables are set.
if (!is.na(params$group_facet)) {
  # do some error checking to make sure the filter and contrasts are set correctly
  if(is.na(params$group_filter)){
    stop("group_facet was set but group_filter is NA! You should probably be running this from another script.")
  }
  # check that group_filter is actually one of the facets
  all_facets = DESeqDesign %>% pull(params$group_facet) %>% unique()
  if(!params$group_filter %in% all_facets){
    stop(paste("group_filter", params$group_filter, "not found in group_facet", params$group_facet))
  }
  
  contrasts_to_filter <- DESeqDesign %>%
  dplyr::filter(!!sym(params$group_facet) %in% params$group_filter) %>% # NOTE: Not sure if %in% or == is better here.
  pull(params$design) %>% 
  unique()
  contrasts <- contrasts %>% dplyr::filter(V1 %in% contrasts_to_filter)
  if (params$strict_contrasts == T) {
    contrasts <- contrasts %>% dplyr::filter(V2 %in% contrasts_to_filter |
                                             V1 %in% contrasts_to_filter  )
  }
  DESeqDesign <- DESeqDesign %>% dplyr::filter(!!sym(params$design) %in% (unlist(contrasts) %>% unique()) )
}
if (any(!is.na(params$exclude_samples))) {
  DESeqDesign <- DESeqDesign %>% dplyr::filter(!original_names %in% params$exclude_samples)
}
if (any(!is.na(params$exclude_groups))) {
  DESeqDesign <- DESeqDesign %>% dplyr::filter(!(!!sym(params$design)) %in% params$exclude_groups)
  contrasts_to_filter <- DESeqDesign %>% 
  dplyr::filter(!(!!sym(params$design)) %in% params$exclude_groups) %>%
  pull(params$design) %>% 
  unique()
  contrasts <- contrasts %>% dplyr::filter(V1 %in% contrasts_to_filter)
  if (params$strict_contrasts == T) {
    contrasts <- contrasts %>% dplyr::filter(V2 %in% contrasts_to_filter |
                                             V1 %in% contrasts_to_filter  )
  }
}
if (!is.na(params$include_only_column) & !is.na(params$include_only_group)) {
  DESeqDesign <- DESeqDesign %>%
    dplyr::filter((!!sym(params$include_only_column)) %in% params$include_only_group)
  limit_contrasts <- DESeqDesign %>%
    pull(!!sym(params$design)) %>%
    unique() %>%
    as.character()
  contrasts <- contrasts %>% dplyr::filter(V1 %in% limit_contrasts)
}

# reorder contrast list by the specified column
if(!is.na(params$sortcol)){
  ordered_design <- DESeqDesign[mixedorder(DESeqDesign[,params$sortcol]),] %>%
    dplyr::select(params$design) %>%
    dplyr::pull()
  contrasts <- contrasts %>%
    dplyr::slice(match(ordered_design, V1)) %>%
    unique()
}

# Once contrasts have been filtered, generate short contrast names for report.
short_contrast_names <- paste(contrasts$V1, "v.", contrasts$V2) # Customize these for your experiment... Must be short enough to fit as Excel tab titles.

# Needed later
ensembl <- NULL
tryCatch({
    ensembl <- useMart("ensembl",
    dataset = ensembl_species,
    host = "https://www.ensembl.org")
}, error = function(err){
    ensembl <- useMart("ensembl",
    dataset = ensembl_species,
    host = "http://uswest.ensembl.org/")
}, error = function(err){
    ensembl <- useMart("ensembl",
    dataset = ensembl_species,
    host = "http://useast.ensembl.org/")
}, error = function(err){
    ensembl <- useMart("ensembl",
    dataset = ensembl_species,
    host = "http://asia.ensembl.org/")
}, finally={
    if (is.null(ensembl)) {stop("Can't connect to Ensembl!")}
})

#Set parameters according to platform
if (Platform == "RNA-Seq") {
  threshold = 1000000 # Number of aligned reads per sample required
  MinCount <- 1
  alpha <- pAdjValue <- 0.05 # Relaxed from 0.01
  linear_fc_filter <- 1.5
  biomart_filter <- "ensembl_gene_id"
} else if (Platform == "TempO-Seq") {
  threshold = 100000 # Number of aligned reads per sample required
  MinCount <- 0.5
  alpha <- pAdjValue <- 0.05 
  linear_fc_filter <- 1.5
  manifest_file <- file.path(params$biospyder_dbs, temposeq_manifest)
  message(paste("loading byiospyder manifest from",manifest_file))
  biospyder <- read.delim(manifest_file, # Assay manifest...
                          stringsAsFactors = FALSE,
                          sep = "\t",
                          header = TRUE,
                          quote = "\"")
  # Annoyingly, the manifests are different depending on platform and version.
  if (colnames(biospyder)[1] == "PROBE_NAME") {
    biospyder_ID = "ENSEMBL_GENE_ID"
    biomart_filter <- "PROBE_NAME"
    biospyder_filter = "ensembl_gene_id"
  } else if (colnames(biospyder)[1] == "Probe.name") {
    biospyder_ID = "Reference.Transcript"
    biomart_filter = "Probe.name"
    biospyder_filter = "refseq_mrna"
  } else if (colnames(biospyder)[1] == "PROBE_ID") {
    # This should be an "or" statement instead... these manifests are so inconsistent.
    # Same general idea as the first case, but slight differences in the Excel file
    # Had to alter PROBE_NAME manually to include the number as XYZ_1
    biospyder_ID = "ENSEMBL_GENE_ID"
    biomart_filter <- "PROBE_NAME"
    biospyder_filter = "ensembl_gene_id"
  } else if (colnames(biospyder)[1] == "Probe.Name") { # mouse S1500, note that spaces arent allowed in R colnames
    biospyder_ID = "Gene.Symbol"
    biomart_filter <- "Probe.Name"
    biospyder_filter = species_gene_symbol
  }

  # Fill in the blanks for TempO-Seq Manifest...
  # Set NULL values to NA
  biospyder[ biospyder == "NULL" ] <- NA

} else { 
  print("Platform/technology not recognized") 
}

```

The code above (not shown by default) loads user-provided sample meta data (i.e., information about your experiment, also known as colData, or, column data). This also imports the count matrix (i.e., a table of observed counts in which each sample is a column and genes are rows).  

The experimental comparisons of interest to be tested in this report are as follows:  

```{r 'print_contrasts'}
knitr::kable(contrasts,
             row.names = F,
             col.names = c("Group of interest", "Control for comparison"),
             caption = "Contrasts requested for this analysis.") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(height = "480px")
```

## Run DESeq2

```{r run-DESeq2, collapse = TRUE, warning = FALSE, message = FALSE}
##########
# DESeq2 #
##########
message(NORM_TYPE) # Name of experiment

# First data clean-up: replace NA & remove samples with total readcount < threshold
initialSampleDataCount <- ncol(sampleData)
sampleData[ is.na(sampleData) ] <- 0 
sampleData <- sampleData[,(colSums(sampleData) > threshold)] # reads required per sample
filteredSampleDataCount <- ncol(sampleData)
# Sometimes extra cleanup may be needed
# colnames(sampleData) <- gsub(pattern = "^0", replacement = "", x = colnames(sampleData))

samples_before <- nrow(DESeqDesignAsRead)

# Sanity check: each sample (row) in the metadata should have a corresponding column in the count data
metadata_in_sampledata <- all(DESeqDesign$original_names %in% colnames(sampleData))
# Sanity check: each column in the count data should have a corresponding sample (row) in the metadata
sampledata_in_metadata <- all(colnames(sampleData) %in% DESeqDesign$original_names)
# Find samples that were removed because they weren't in metadata
removed <- colnames(sampleData[which(!colnames(sampleData) %in% DESeqDesign$original_names)])
# Reorder the metadata table to correspond to the order of columns in the count data
DESeqDesign <- DESeqDesign[DESeqDesign$original_names %in% colnames(sampleData),]
# DESeqDesign <- na.omit(DESeqDesign) # This can cause issues since it removes any lines with missing data. Should instead check for NAs in required columns.
sampleData <- sampleData[,DESeqDesign$original_names]
samples_after <- nrow(DESeqDesign)

head(DESeqDesign$original_names)
head(colnames(sampleData)) # Output should match

# Intgroups need to be factors for DESeq2
DESeqDesign[intgroup] <- lapply(DESeqDesign[intgroup], factor)
if (!is.na(params$design)) {
  if (!is.na(params$sortcol)) {
    design_factor_reordered <- factor(DESeqDesign[[params$design]],
                                      levels = unique(DESeqDesign[[params$design]][mixedorder(DESeqDesign[[params$sortcol]])]),
                                      ordered = FALSE)
    DESeqDesign[[params$design]] <- design_factor_reordered
  }
}

if (file.exists(file.path(paths$RData, "dds.RData")) & is.na(params$group_facet) & params$use_cached_RData == TRUE) {
  print(paste("Already found DESeq2 object from previous run; loading from disk."))
  load(file.path(paths$RData, "dds.RData"))
  if (!identical(as.data.frame(round(counts(dds))),
                 round(sampleData), 0)) {
    print("Not identical")
    }
  } else {
    if (file.exists(file.path(paths$RData,
                             paste0("dds_",
                                    paste(params$group_filter, collapse = "_"),
                                    ".RData"))) & 
       !is.na(params$group_facet) & 
       params$use_cached_RData == TRUE) {
      load(file = file.path(paths$RData,
                          paste0("dds_",
                                 paste(params$group_filter, collapse = "_"),
                                 ".RData")))
      } else {
      current_design <- formula(paste0(paste0("~"),
                                       paste0(intgroup, collapse = " + ")))
      dds <- DESeqDataSetFromMatrix(countData = round(sampleData),
                                    colData   = as.data.frame(DESeqDesign),
                                    design    = current_design)
      # This orders the DESeq object the same as sample metadata...
      dds <- dds[, DESeqDesign$original_names]
      dds <- dds[rowSums(counts(dds)) > 1]
      bpparam <- MulticoreParam(params$cpus)
      dds <- DESeq(dds, parallel = TRUE, BPPARAM = bpparam)
      if (is.na(params$group_facet)) {
        save(dds,
             file = file.path(paths$RData, "dds.RData"))
      } else {
        save(dds,
             file = file.path(paths$RData,
                            paste0("dds_",
                                   paste(params$group_filter, collapse = "_"),
                                   ".RData")))
      }
    }
}

# ### REMOVE if done above from scratch
# keep <- grep(colData(dds)$chemical, pattern = "cells", invert = T, ignore.case = T)
# dds <- dds[, keep]
# dds <- dds[row.names(dds) %in% biospyder$ENSEMBL_GENE_ID,]

# Another sanity check to make sure the object looks correct
resultsNames(dds)
head(colData(dds))
head(assay(dds))
head(rowRanges(dds))
str(counts(dds))

# Make regularized log object for later plotting
# rld <- tryCatch(rlog(dds), error = function(e) { rlog(dds, fitType = 'mean') })
# Use vst for hundreds of samples!

if (!is.na(params$batch_var)) {
  rld <- vst(dds, blind = F) # Should this be blind?
  mat <- assay(rld)
  condition <- formula(paste0(paste0("~"),
                              paste0(intgroup[!intgroup %in% params$batch_var],
                                     collapse = " + ")))
  mm <- model.matrix(condition, colData(rld))
  mat <- limma::removeBatchEffect(mat, batch = rld[[params$batch_var]], design = mm)
  assay(rld) <- mat
} else {
  rld <- vst(dds, blind = F) # Should this be blind?
}

# rld <- rlog(dds, blind = F)
```

The code above (not shown by default) uses DESeq2 `r packageVersion("DESeq2")` to test for deferentially abundant genes within the `r Platform` data.  

# Quality control

A study-wide quality control script removes samples that cluster at a distance greater than a specified cutoff, samples that are noisy, and samples that do not have sufficient aligned reads. **More details are available in a separate report.**  

Within this report, gene/probe-level quality control is performed below ("Run pairwise comparisons" section).

Prior to running DESeq2, the data was filtered to remove samples that do not have $`r threshold`$ reads per sample.  

The metadata used for this report included `r samples_before` samples.  

The count matrix initially included `r initialSampleDataCount` samples (including any reference material samples). After removing samples with less than $`r threshold`$ reads, `r filteredSampleDataCount` samples were left. It is `r metadata_in_sampledata` that all the samples provided in the metadata table were also identified in the count matrix. It is `r sampledata_in_metadata` that all the samples in the count matrix were also identified in the metadata table.  

There were `r samples_after` samples passing all thresholds. **The samples excluded from analysis are shown in the table in the section titled "Sample data", below, along with complete sample metadata for the experiment.**    

## Sample data (metadata about your experiment) {.tabset .tabset-fade}

**Some samples may already have been removed in study-wide QC.**

### Samples used in this report

This table shows the final list of samples that were used in the data analysis (as well as the corresponding sample information, e.g., to which experimental group samples belong).  

```{r print_metadata_used}
# Conditionally sort by dose if that column name is present
if (!is.na(params$dose)) {
  knitr::kable(DESeqDesign %>%
                 group_by(!!sym(params$design)) %>%
                 arrange(!!sym(params$dose)),
               row.names =  F,
               caption = "Samples and corresponding experimental conditions used in this report") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
    scroll_box(width = "100%", height = "480px")
} else {
  knitr::kable(DESeqDesign %>% arrange(!!sym(params$design)),
             row.names =  F,
             caption = "Samples and corresponding experimental conditions used in this report") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  scroll_box(width = "100%", height = "480px")
}

knitr::kable(DESeqDesign %>% group_by(!!sym(params$design)) %>% tally(),
             row.names = F,
             col.names = c("Experimental group", "Number of samples in group"),
             caption = "Number of samples in each experimental group used in this report") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```

### Samples removed from this report

This table shows the samples that were removed from this analysis.

```{r print_metadata_removed}
# Conditionally sort by dose if that column name is present?
knitr::kable(DESeqDesignAsRead %>% arrange(!!sym(params$design)) %>% dplyr::filter(!original_names %in% DESeqDesign$original_names),
             row.names =  F,
             caption = "Samples removed from analysis") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  scroll_box(width = "100%", height = "480px")

knitr::kable(DESeqDesignAsRead %>%
               dplyr::filter(original_names %in% removed) %>%
               group_by(!!sym(params$design)) %>% tally(),
             row.names = F,
             col.names = c("Experimental group", "Number of samples removed"),
             caption = "Number of samples removed from each experimental group") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```

### Original sample metadata as provided

This table shows the original sample metadata including any samples that were removed within this report.  **Note that some samples may already have been removed in study-wide QC before loading this metadata.**

```{r print_metadata_provided}
# Conditionally sort by dose if that column name is present?
knitr::kable(DESeqDesignAsRead %>% arrange(!!sym(params$design)),
             row.names =  F,
             caption = "Complete sample metadata as provided to the Genomics Laboratory.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  scroll_box(width = "100%", height = "480px")

knitr::kable(DESeqDesignAsRead %>% group_by(!!sym(params$design)) %>% tally(),
             row.names = F,
             col.names = c("Experimental group", "Number of samples as provided"),
             caption = "Number of samples and experimental groups as provided") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```

## Read count plots

This section shows the number of reads obtained for sample groups included in the report.  

```{r read-counts, warning = FALSE}
reads_df = data.frame(reads = round(colSums(sampleData), 3))
reads_df$original_names <- row.names(reads_df)

reads_df_annotated <- dplyr::left_join(DESeqDesign, reads_df)

ggplot(reads_df_annotated,
       aes(x = !!sym(params$design),
           y = reads)) +
  geom_boxplot() +
  geom_jitter(size = 0.3, alpha = 0.5, color = "blue") +
  coord_flip() +
  expand_limits(y = 0) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
```

# Testing for differentially expressed genes

## Run pairwise comparisons

```{r 'run_ODAF_code', collapse = TRUE, warning = FALSE, message = FALSE}

# Initial setup for DESeq2 contrasts
cooks   <- F # Sometimes may need consideration
resListAll <- list() # all results
resListFiltered <- list() # ODAF filtering applied
resListSig <- list() # ODAF filtering applied, significant results only
filterList <- list()
Counts  <- counts(dds, normalized = TRUE)
CPMdds  <- cpm(counts(dds, normalized = TRUE))

for (x in 1:nrow(contrasts)) {	# For all comparisons to be done	
	
	condition1 <- contrasts[x, 2] # Control
	condition2 <- contrasts[x, 1] # Experimental
	print(paste(condition2, " vs ", condition1, ":", NORM_TYPE))
	
	DE_Design <- matrix(data = NA, ncol = 2)
	DE_Design <- as.matrix(DESeqDesign[DESeqDesign[, DESIGN] %in% c(condition1,
	                                                               condition2),])
	# To fix a problem below, we could re-order DE_Design to match the DESeq object
	# But it's a subset of the data... so that would be difficult.
	samples   <- sampleData[, DE_Design[, "original_names"]]
	colnames(samples) <- NULL
	
	###########

	print(paste0("Filtering genes: 75% of at least 1 group need to be above ", MinCount, " CPM"))
	SampPerGroup <- table(DE_Design[, DESIGN])
	if (!SampPerGroup[condition2] > 1) { next }
  Counts <- counts(dds, normalized = TRUE)
  CPMdds <- cpm(counts(dds, normalized = TRUE))
  		
  Filter <- matrix(data = NA, ncol = 3, nrow = nrow(Counts))
  rownames(Filter) <- rownames(Counts)
  colnames(Filter) <- c("Low", "quantile", "spike")
  		
  # Apply the "Relevance" condition
  	
  	for (gene in 1:nrow(dds)) {
  		CountsPass <- NULL
  			for (group in 1:length(SampPerGroup)) { 
  			  # This line gets "sampleCols" from the DE_Design table.
  				sampleCols <- grep(names(SampPerGroup)[group], DE_Design[, DESIGN])
  				# The line below assumes that the columns in CPMdds are ordered the same as the DE_Design table.
  				# That is not necessarily true. Instead, first get the explicit row names as a vector.
  				sampleNamesGroup <- DE_Design[sampleCols, "original_names"]
  				Check <- sum(CPMdds[gene, sampleNamesGroup] >= MinCount) >= 0.75 * SampPerGroup[group]
  				CountsPass <- c(CountsPass, Check)
  		}
  	if (sum(CountsPass) > 0) {Filter[gene, 1] <- 1 } else {Filter[gene, 1] <- 0 }
  	}
  # Create counts matrix for which relevance filtering passed
  # Then remove rows from the filter table that don't include those genes
  compte <- Counts[Filter[, 1] == 1,] 
  Filter <- Filter[rownames(Filter) %in% rownames(compte), , drop = F]

  print(paste0("Relevance filtering removed ", nrow(dds) - nrow(Filter),
              " genes from the ", nrow(dds)," assessed. ",
              nrow(Filter), " genes remaining"))
	
  print("Obtaining the DESeq2 results")

	currentContrast <- c(DESIGN, condition2, condition1)
	bpparam <- MulticoreParam(params$cpus)
	res <- DESeq2::results(dds[rownames(compte),],
	                       alpha = alpha,
	                       parallel = TRUE,
	                       BPPARAM = bpparam,
	                       contrast = currentContrast,
	                       pAdjustMethod = 'fdr',
	                       cooksCutoff = cooks) # If Cooks cutoff disabled - manually inspect.
	res <- lfcShrink(dds = dds[rownames(compte),],
	                 contrast = currentContrast,
	                 BPPARAM = bpparam,
	                 res = res,
	                 type = "ashr")
	resListAll[[x]] <- res
	
	NORM_TYPE <- gsub(" ", "_", NORM_TYPE, fixed = TRUE)
	FileName <- paste(NORM_TYPE, condition2, "vs", condition1, "FDR", pAdjValue, sep = "_")
	# Create output tables
	norm_data <<- counts(dds[rownames(compte)], normalized = TRUE)
	DEsamples <<- subset(res, res$padj < pAdjValue)
	if (nrow(DEsamples) == 0) {
	  print("No significant results were found for this contrast. Moving on...")
	  next
	  }
	DECounts <- compte[rownames(compte) %in% rownames(DEsamples), , drop = F]
	Filter <- Filter[rownames(Filter) %in% rownames(DECounts), , drop = F]
	
	print("Check median against third quantile" )
	print("AND")
	print("Check the presence of a spike" )

	for (gene in 1:nrow(DECounts)) {
	  # Check the median against third quantile
		quantilePass <- NULL
		sampleColsg1 <- grep(dimnames(SampPerGroup)[[1]][1],DE_Design[,DESIGN])
		sampleColsg2 <- grep(dimnames(SampPerGroup)[[1]][2],DE_Design[,DESIGN])
		
		# Same problem as above, use names explictly
		sampleNames_g1 <- DE_Design[sampleColsg1, "original_names"]
		sampleNames_g2 <- DE_Design[sampleColsg2, "original_names"]
		
	  Check <- median(as.numeric(DECounts[gene, sampleNames_g1])) > quantile(DECounts[gene, sampleNames_g2], 0.75)[[1]]
		quantilePass <- c(quantilePass, Check)
		
		Check <- median(as.numeric(DECounts[gene, sampleNames_g2])) > quantile(DECounts[gene, sampleNames_g1], 0.75)[[1]]
		quantilePass <- c(quantilePass, Check)
			
		if (sum(quantilePass) > 0 ) {
		  Filter[gene, 2] <- 1
		} else {
		  Filter[gene, 2] <- 0
		}

		# Check for spikes 
		spikePass <- NULL
		for (group in 1:length(SampPerGroup)) {
				sampleColsSpike <- grep(dimnames(SampPerGroup)[[1]][group], DE_Design[ ,DESIGN])
				sampleNamesSpike <- DE_Design[sampleColsSpike, "original_names"]
			if (max(DECounts[gene, sampleColsSpike]) == 0) {Check <- FALSE} else {
				Check <- (max(DECounts[gene, sampleColsSpike]) / sum(DECounts[gene, sampleColsSpike])) >= 1.4 * (SampPerGroup[group])^(-0.66)
				spikePass <- c(spikePass, Check)
			}
		}
		if (sum(spikePass) > 1) {
		  Filter[gene, 3] <- 0
		}	else {
		  Filter[gene, 3] <- 1
		}
	}
	
	# Extract the final list of DEGs
	allCounts_all_filters <- res[rowSums(Filter) == 3 ,]
	DECounts_all_filters <- DEsamples[rowSums(Filter) == 3 ,]
	DECounts_no_quant <- DEsamples[Filter[, 2] == 0 ,]
	DECounts_spike <- DEsamples[Filter[, 3] == 0 ,]
	
  print(paste0("A total of ", nrow(DECounts_all_filters),
              " DEGs were selected, after ", nrow(DECounts_no_quant),
              " genes(s) removed by the quantile rule and ", nrow(DECounts_spike),
              " gene(s) with a spike"))
  
  filterList[[x]] <- Filter # Useful to explore later...
  
  # Save the R-ODAF tables
  # Except the first two which are redundant with other ones produced
  #	write.table(norm_data,
  #            file = file.path(paths$ODAFdir, paste0(FileName, "_Norm_Data.txt")),
  #            sep = "\t", quote = FALSE)
	write.table(DEsamples,
	            file = file.path(paths$ODAFdir, paste0(FileName, "_DEG_table.txt")),
	            sep = "\t", quote = FALSE)
	write.table(DECounts_no_quant,
	            file = file.path(paths$ODAFdir, paste0(FileName, "_failed_quantile_table.txt")),
	            sep = "\t", quote = FALSE)
	write.table(DECounts_spike,
	            file = file.path(paths$ODAFdir, paste0(FileName, "_DEspikes_table.txt")),
	            sep = "\t", quote = FALSE)

	print("DESeq2 Done")
	
	colnames(norm_data) <- colData(dds)[, DESIGN]

	resListSig[[x]] <- DECounts_all_filters
	resListFiltered[[x]] <- allCounts_all_filters

}
# If there are no significant results - remove the empty contrast from the list:
# Can this be moved later? Need to list "0" for DEG summary where contrasts have nothing.
resListSig <- resListSig[!sapply(resListSig, is.null)]
resListAll <- resListAll[!sapply(resListAll, is.null)]
resListFiltered <- resListFiltered[!sapply(resListFiltered, is.null)]
```

The code above (not shown by default) runs the R-ODAF spurious spike detection and outputs the DESeq Results objects as a list for each contrast. As specified by the R-ODAF guidelines, 75% of at least 1 group need to be above `r MinCount` CPM and spurious spikes were removed in which Max-Median > Sum/(Rep + 1).  

The log2FoldChange shrinkage procedure used was `r resListAll[[1]]@priorInfo$type`. An alpha of `r resListAll[[1]]@metadata$alpha` was used to extract raw results, which are reported as the `r gsub(mcols(x=resListAll[[1]])$description[[4]],pattern=":.*",replacement="")`. To account for multiple testing, `r mcols(resListAll[[1]])$description[5]` are reported. Cook's cutoff was set to `r cooks` in this analysis.  


## Create annotation tables

```{r}
################################################################################
# Annotations
################################################################################
# Compile list of all potentially relevant genes
genes <- lapply(resListAll,
                function(x) row.names(as.data.frame(x)))
genes <- unlist(genes) %>% unique()

# listEnsembl()
# listMarts()
# listDatasets(useMart('ensembl'))
# listAttributes(ensembl)
# listFilters(ensembl)

if (Platform == "TempO-Seq") {
  genes <- biospyder[biospyder[[biomart_filter]] %in% genes,] %>% pull(!!ensym(biospyder_ID))
  id_table_entrez <- getBM(filters = biospyder_filter,
                        attributes = c(biospyder_filter,
                                      species_gene_symbol,
                                      "description",
                                      "entrezgene_id",
                                      "ensembl_gene_id"), # in case not included
                        values = genes,
                        mart = ensembl)
  save(id_table_entrez, file = file.path(paths$RData, "id_table.Rdata"))
  # Add probe ID to annotations for future ability to link them
  id_table_entrez <- id_table_entrez %>%
    dplyr::left_join(biospyder,
                     by = setNames(biospyder_ID, biospyder_filter) )
  id_table_entrez[,biomart_filter] <- id_table_entrez[,biomart_filter] #hackity hack hack for mouse S1500 - extra hack for cases where probe name isn't the column name
  # Note that the setNames() function above actually reverses the arguments...
  id_table <- id_table_entrez[, c(biomart_filter,
                                  "ensembl_gene_id",
                                  species_gene_symbol,
                                  "description")] # Manageable subset of the annotations
} else {
  id_table_entrez <- getBM(filters = biomart_filter,
                        attributes = c(biomart_filter,
                                      species_gene_symbol,
                                      "description",
                                      "entrezgene_id",
                                      "entrezgene_accession"),
                        values = genes,
                        mart = ensembl)
  # To eventually replace biomaRt?
  # Needs attention to detail to either preserve column names
  # Or alternatively rename for consistency with OrgDb naming throughout script.
  # clusterProfiler::bitr(genes,
  #                       fromType = "ENSEMBL",
  #                       toType = c("ENTREZID","SYMBOL",),
  #                       OrgDb = orgdb)
  
  save(id_table_entrez, file = file.path(paths$RData, "id_table.Rdata"))
  id_table <- id_table_entrez[, 1:3] # Manageable subset of the annotations
}
```


## Create summary tables

```{r create_tables, collapse = TRUE, warning = FALSE, message = FALSE}
################################################################################
# Table modifications
################################################################################

annotate_deseq_table <- function(deseq_results_list, filter_results = F) {
  x <- deseq_results_list
  annotated_results <- list()
  for (i in 1:length(x)) {
    print(i)
    deg_table <- x[[i]]
    # Add taxonomy
    if (is.null(deg_table)) {
      next
    } else if (nrow(deg_table) == 0) {
      next
    } else {
      deg_table <- cbind(genes = row.names(x[[i]]),
                      as(deg_table, "data.frame"),
                      contrast = gsub(pattern = paste0("log2.*", DESIGN, "\ "),
                                      replacement =  "",
                                      x = x[[i]]@elementMetadata[[2]][2]))
      names(deg_table)[names(deg_table) == "genes"] <- biomart_filter
      deg_table <- dplyr::left_join(deg_table,
                                    id_table,
                                    by = biomart_filter)
      deg_table <- dplyr::mutate(deg_table, linearFoldChange = ifelse(log2FoldChange > 0,
                                                              2 ^ log2FoldChange,
                                                              -1 / (2 ^ log2FoldChange)))
      if (Platform == "TempO-Seq") {
        deg_table <- deg_table[, c(1, 8:10, 2, 3, 11, 4:7)]
        # Depends on whether you include extra column for ensembl...
        # deg_table <- deg_table[, c(1, 8, 9, 2, 3, 10, 4:7)]
      } else {
        deg_table <- deg_table[, c(1, 8, 9, 2, 3, 10, 4:7)]
      }
      ## FILTERS ##
      if (filter_results == T) {
      deg_table <- deg_table[!is.na(deg_table$padj) & deg_table$padj < alpha & abs(deg_table$linearFoldChange) > linear_fc_filter, ]
      }
      annotated_results[[i]] <- deg_table %>% dplyr::distinct()
    }
  }
  y <- rbindlist(annotated_results)
  return(y)
}

# Write dataframe of all results
# Significant only
significantResults <- annotate_deseq_table(resListSig, filter_results = T)
significantResults <- significantResults %>% dplyr::mutate(contrast = as_factor(contrast))
# Significant genes, not filtered additionally by the above function
ODAFResults <- annotate_deseq_table(resListSig, filter_results = F)
# All results including non-significant
allResults <- annotate_deseq_table(resListAll, filter_results = F)
allResults <- allResults %>% dplyr::mutate(contrast = as_factor(contrast))

# All Results for Plotting
# Replace NA gene symbols with ensembl ID
allResults[[species_gene_symbol]][is.na(allResults[[species_gene_symbol]])] <- allResults[[biomart_filter]][is.na(allResults[[species_gene_symbol]])] 
# Replace blank gene symbols with ensembl ID
allResults[[species_gene_symbol]][allResults[[species_gene_symbol]] == ""]  <- allResults[[biomart_filter]][allResults[[species_gene_symbol]] == ""]

IPA <- allResults %>% 
  distinct() %>% 
  pivot_wider(names_from = contrast, values_from = c(log2FoldChange, linearFoldChange, lfcSE, pvalue, padj))
allResults$padj[allResults$padj == 0] <- 10^-100 # For plotting purposes!
allResultsOrdered_logFC_filter <- dplyr::filter(allResults, abs(linearFoldChange) > 1.5) %>%
  arrange(-abs(linearFoldChange))
allResultsOrdered_logFC_filter <- dplyr::filter(allResultsOrdered_logFC_filter, padj < alpha)
res.df <- allResultsOrdered_logFC_filter

# Need to ensure that contrasts with no DEGs are reported.
degTable <- as.data.frame(levels(allResults$contrast))
colnames(degTable) <- "contrast"
degTable_n <- significantResults %>%
  dplyr::group_by(contrast) %>%
  dplyr::count()
degTable <- degTable %>%
  left_join(degTable_n, by = "contrast", na_matches = "never")

summaryTable <- allResults %>%
  dplyr::select(!!ensym(biomart_filter), baseMean)
contrastsInSummary <- vector()
for (i in 1:length(resListSig)) {
  print(i)
  n <- resListSig[[i]]@elementMetadata[[2]][2]
  n <- gsub(pattern = paste0("log2\ fold\ change\ \\(MMSE\\):\ ", DESIGN), # Might need to be MLE for some tests
            replacement =  paste0("log2 Fold Change"),
            x = resListSig[[i]]@elementMetadata[[2]][2])
  p <- gsub(pattern = paste0("log2\ fold\ change\ \\(MMSE\\):\ ", DESIGN),
           replacement =  resListSig[[i]]@elementMetadata[[2]][6], # Not used?
           x = resListSig[[i]]@elementMetadata[[2]][2])
  q <- gsub(pattern = paste0("log2\ fold\ change\ \\(MMSE\\):\ ", DESIGN, "\ "),
            replacement =  "",
            x = resListSig[[i]]@elementMetadata[[2]][2])
  toJoin <- as.data.frame(resListSig[[i]])
  setDT(toJoin, keep.rownames = T)[]
  setnames(toJoin, 1, biomart_filter)
  toJoin <- mutate(toJoin, linearFoldChange = ifelse(log2FoldChange > 0,
                                                2 ^ log2FoldChange,
                                                -1 / (2 ^ log2FoldChange)))
  toJoin <- toJoin[, c(1:3, 7, 4:6)]
  summaryTable <- dplyr::left_join(summaryTable, dplyr::select(toJoin, !c(baseMean, pvalue, lfcSE)), by = biomart_filter)

  names(summaryTable)[[ncol(summaryTable) - 2]] <- paste0("log2FoldChange_", i)
  names(summaryTable)[[ncol(summaryTable) - 1]] <- paste0("linearFoldChange_", i)
  names(summaryTable)[[ncol(summaryTable)]] <- paste0("FDR_", i)
  contrastsInSummary[i] <- q
  print(summary(resListSig[[i]], pAdjValue))
}

maxFCs <- allResults %>%
  dplyr::group_by(!!sym(biomart_filter)) %>%
  dplyr::filter(abs(linearFoldChange) == max(abs(linearFoldChange))) %>%
  dplyr::ungroup() %>%
  dplyr::select(!!sym(biomart_filter), linearFoldChange)

minPvals <- allResults %>%
  group_by(!!sym(biomart_filter)) %>%
  dplyr::filter(padj == min(padj)) %>%
  dplyr::ungroup() %>%
  dplyr::select(!!sym(biomart_filter), padj)

summaryTable <- summaryTable %>%
  left_join(id_table, by = biomart_filter) %>%
  left_join(maxFCs, by = biomart_filter) %>%
  left_join(minPvals, by = biomart_filter) %>%
  dplyr::rename(maxFoldChange = linearFoldChange,
         minFDR_pval = padj) %>%
  dplyr::distinct() %>%
  mutate(maxFoldChange = abs(maxFoldChange)) # This eliminates the direction of change: this way it's easy to sort.

numColsToPrepend <- ncol(summaryTable) - 3*length(resListSig) - 2 # Number of columns per contrast = 3. Subtract two for the baseMean and genes columns.
colPositionsToPrependSTART <- ncol(summaryTable) - numColsToPrepend + 1
colPositionsOfData <- ncol(summaryTable) - numColsToPrepend
summaryTable <- as.data.frame(summaryTable)
summaryTable <- summaryTable[, c(1,
                                colPositionsToPrependSTART:ncol(summaryTable),
                                2:colPositionsOfData)]
summaryTable <- summaryTable %>% dplyr::distinct() # Just in case duplicates snuck by

CPMddsDF <- data.frame(genes = row.names(CPMdds), CPMdds, check.names = F)
CPMddsDF <- dplyr::left_join(CPMddsDF, id_table, by = c("genes" = biomart_filter))
numColsToPrepend <- ncol(CPMddsDF) - ncol(CPMdds) - 1
colPositionsToPrependSTART <- ncol(CPMddsDF) - numColsToPrepend + 1
colPositionsOfData <- ncol(CPMddsDF) - numColsToPrepend
CPMddsDF <- CPMddsDF[, c(1, colPositionsToPrependSTART:ncol(CPMddsDF), 2:colPositionsOfData)]


```

The code above (not shown by default) generates tables summarizing the differentially expressed genes (DEGs).  A linear fold change cutoff of `r linear_fc_filter` and adjusted p-value of `r alpha` was used to filter the results.

Here is the number of DEGs in each group:

```{r 'display_DEG_summary'}
kable(degTable,
      caption = "Number of differentially expressed genes across each contrast") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

```{r 'write-tables', collapse = TRUE, warning = FALSE, message = FALSE}
#######################################
### Write results table from DESeq2
#######################################
degSummary <- rbind(c(params$group_filter, degTable[[1]]),
                    c(params$group_filter, degTable[[2]]))

write.table(allResults,
            file = file.path(paths$DEG_output,
                             paste0(NORM_TYPE,"-DESeq_output_ALL.txt")),
            quote = F, sep = '\t', col.names = NA)
write.table(significantResults,
            file = file.path(paths$DEG_output,
                             paste0(NORM_TYPE, "-DESeq_output_significant.txt")),
            quote = F, sep = '\t', col.names = NA)
write.table(summaryTable,
            file = file.path(paths$DEG_output,
                             paste0(NORM_TYPE, "-DESeq_output_all_genes.txt")),
            quote = F, sep = '\t', col.names = NA)
write.table(CPMddsDF,
            file = file.path(paths$DEG_output,
                             paste0(NORM_TYPE, "-Per_sample_CPM.txt")),
            quote = F, sep = '\t', col.names = NA)
write.table(Counts,
            file = file.path(paths$DEG_output,
                             paste0(NORM_TYPE, "-Per_sample_normalized_counts.txt")),
            quote = F, sep = '\t', col.names = NA)
write.table(degSummary,
            file = file.path(paths$DEG_output,
                             paste0(NORM_TYPE, "-DEG_summary.txt")),
            quote = F, sep = '\t', col.names = FALSE, row.names = FALSE)
```

The code above (not shown by default) writes text files for each DEG summary type.

# Write data

```{r 'write-excel-worksheets', collapse = TRUE, warning = FALSE, message = FALSE}
#######################################
### Write results above but in Excel
#######################################
### Global options
options("openxlsx.borderColour" = "#4F80BD")
options("openxlsx.borderStyle" = "thin")
options("openxlsx.maxWidth" = 50)
hs1 <- createStyle(textDecoration = "Bold",
                   border = "Bottom",
                   fontColour = "black")
hs2 <- createStyle(textDecoration = "Bold",
                   border = c("top", "bottom", "left", "right"),
                   fontColour = "black",
                   fgFill = "#C5D9F1")

### Summary results - one gene per line, columns are contrasts
wb1 <- createWorkbook()
modifyBaseFont(wb1, fontSize = 10, fontName = "Arial Narrow")
addWorksheet(wb1, "DESeq_results_per_gene")
for (j in 1:length(contrastsInSummary)) {
  myStartcol = 8 + ((j - 1) * 3)
  myEndcol = 10 + ((j - 1) * 3)
  mergeCells(wb1,
             sheet = 1,
             cols = myStartcol:myEndcol,
             rows = 1)
  writeData(
    wb1,
    sheet = 1,
    x = contrastsInSummary[j],
    startCol = myStartcol,
    startRow = 1)
}
conditionalFormatting(wb1,
                      sheet = 1,
                      rows = 1,
                      cols = 1:ncol(summaryTable),
                      type = "contains",
                      rule = "",
                      style = hs2)
freezePane(wb1, sheet = 1, firstActiveRow = 3, firstActiveCol = 4)
writeDataTable(wb1,
               sheet = 1,
               startRow = 2,
               x = summaryTable,
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb1, sheet = 1, cols = 1:6, widths = "auto") # This is hard-coded, so prone to error; will only impact auto adjustment of col widths.
setColWidths(wb1, sheet = 1, cols = 7:ncol(summaryTable), widths = 13) # This is hard-coded, so prone to error; will only impact auto adjustment of col widths.
fname1 <- file.path(paths$DEG_output, paste0("1.", NORM_TYPE, "-DESeq_by_gene.xlsx"))
saveWorkbook(wb1, fname1, overwrite = TRUE)

### All results in one table
wb2 <- createWorkbook()
modifyBaseFont(wb2, fontSize = 10, fontName = "Arial Narrow")
addWorksheet(wb2, paste0("FDR", pAdjValue, ".Linear.FC.", linear_fc_filter))
freezePane(wb2, sheet = 1, firstRow = TRUE, firstActiveCol = 4)
writeDataTable(wb2,
               sheet = 1,
               x = significantResults,
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb2, sheet = 1, cols = 1:ncol(significantResults), widths = "auto")
addWorksheet(wb2, "DESeq_all_results")
freezePane(wb2, sheet = 2, firstRow = TRUE, firstActiveCol = 4)
writeDataTable(wb2,
               sheet = 2,
               x = allResults,
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb2, sheet = 2, cols = 1:ncol(allResults), widths = "auto")
fname2 <- file.path(paths$DEG_output, paste0("2.", NORM_TYPE, "-DESeq_all.xlsx"))
saveWorkbook(wb2, fname2, overwrite = TRUE)

### All results with different tabs for each contrast
wb3 <- createWorkbook()
modifyBaseFont(wb3, fontSize = 10, fontName = "Arial Narrow")

short_contrast_names <- stringr::str_trunc(short_contrast_names,
                                           31,
                                           side = "right",
                                           ellipsis = "")
# Get rid of illegal characters... I'm sure there will be more some day
short_contrast_names <- gsub(pattern = ":",
                             replacement = ".",
                             x = short_contrast_names)

for (i in 1:length(levels(factor(allResults$contrast)))) {
  print(i)
  dataToWrite <- allResults[allResults$contrast == levels(factor(allResults$contrast))[i],]
  addWorksheet(wb3, short_contrast_names[i])
  freezePane(wb3, sheet = i, firstRow = TRUE, firstActiveCol = 4)
  writeDataTable(wb3,
                 sheet = i,
                 x = dataToWrite,
                 colNames = TRUE,
                 rowNames = F,
                 tableStyle = "none",
                 headerStyle = hs1,
                 keepNA = T,
                 na.string = "NA")
  setColWidths(wb3, sheet = i, cols = 1:ncol(dataToWrite), widths = "auto")
}
fname3 <- file.path(paths$DEG_output, paste0("3.", NORM_TYPE, "-DESeq_by_contrast.xlsx"))
saveWorkbook(wb3, fname3, overwrite = TRUE)

### CPM
wb4 <- createWorkbook()
modifyBaseFont(wb4, fontSize = 10, fontName = "Arial Narrow")
addWorksheet(wb4, "Counts per million")
freezePane(wb4, sheet = 1, firstRow = TRUE, firstActiveCol = 4)
writeDataTable(wb4,
               sheet = 1,
               x = as.data.frame(CPMddsDF),
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb4, sheet = 1, cols = 1:ncol(CPMddsDF), widths = "auto")
fname4 <- file.path(paths$DEG_output, paste0("4.", NORM_TYPE, "-CPM.xlsx"))
saveWorkbook(wb4, fname4, overwrite = TRUE)

### IPA
wb5 <- createWorkbook()
modifyBaseFont(wb5, fontSize = 10, fontName = "Arial Narrow")
addWorksheet(wb5, "For IPA upload")
freezePane(wb5, sheet = 1, firstRow = TRUE, firstActiveCol = 5)
writeDataTable(wb5,
               sheet = 1,
               x = as.data.frame(IPA),
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb5, sheet = 1, cols = 1:ncol(IPA), widths = "auto")
fname5 <- file.path(paths$DEG_output, paste0("5.", NORM_TYPE, "-IPA.xlsx"))
saveWorkbook(wb5, fname5, overwrite = TRUE)

```

The code above (not shown by default) writes Excel workbooks and text files of DEG lists.

These files should be provided to you as a separate zip file.

# PCA Plots {.tabset .tabset-fade}

## All `r nrow(assay(rld))` genes, before filtering

```{r 'PCA'}
## Perform PCA analysis
data_pca <- plotPCA(rld, intgroup = params$design, ntop = nrow(assay(rld)), returnData = TRUE)
## Get percent of variance explained
percentVar <- round(100 * attr(data_pca, "percentVar"))
## Plot
highlight_pca <- highlight_key(data_pca, ~group)
p <- plot_ly(data = highlight_pca,
        x = ~PC1,
        y = ~PC2,
        color = ~group,
        text = ~name,
        type = "scatter",
        mode = "markers") %>%
  layout(xaxis = list(title = paste0("PC1: ", percentVar[1] ,"% variance")),
         yaxis = list(title = paste0("PC2: ", percentVar[1] ,"% variance")))
highlight( p, on = "plotly_click", off = "plotly_doubleclick", color = "red" )

```

This plot shows the first two principal components that explain the variability in the data using the regularized log count data. If you are unfamiliar with principal component analysis, you might want to check the [Wikipedia entry](https://en.wikipedia.org/wiki/Principal_component_analysis) or this [interactive explanation](http://setosa.io/ev/principal-component-analysis/). In this case, the first and second principal component explain `r percentVar[1]` and `r percentVar[2]` percent of the variance respectively.

## DEGs only (`r length(unique(significantResults[[biomart_filter]]))` genes)

```{r 'PCA_DEGs'}
rld_degs_names <- significantResults[[biomart_filter]] %>% unique()
if (length(rld_degs_names) > 1) {
  rld_degs <- rld[row.names(assay(rld)) %in% significantResults[[biomart_filter]],] 
  # df[df[[THECOLUMN]] == someValue, ] # quick reference because I forget a lot
  ## Perform PCA analysis and make plot
  PCAplotDEGs <- plotPCA(rld_degs,
                         intgroup = params$design,
                         ntop = nrow(rld_degs),
                         returnData = TRUE)

  ## Get percent of variance explained
  percentVarDEGs <- round(100 * attr(PCAplotDEGs, "percentVar"))
  highlight_PCAplotDEGs <-  highlight_key(PCAplotDEGs, ~group)
  p <- plot_ly(data = highlight_PCAplotDEGs,
        x = ~PC1,
        y = ~PC2,
        color = ~group,
        text = ~name,
        type = "scatter") %>%
  layout(xaxis = list(title = paste0("PC1: ", percentVarDEGs[1] ,"% variance")),
         yaxis = list(title = paste0("PC2: ", percentVarDEGs[1] ,"% variance")))
  highlight( p, on = "plotly_click", off = "plotly_doubleclick", color = "red" )
} else {
  print("Insufficient DEGs found.")
  percentVarDEGs <- 0
}

```

This plot shows the principal components analysis limited to all DEGs. In this case, the first and second principal component explain `r percentVarDEGs[1]` and `r percentVarDEGs[2]` percent of the variance respectively.

## Top `r nBest` most variable genes only

```{r 'PCA_top'}

# Run this code only once for both the PCA and clustering analysis
rv = rowVars(assay(rld))
select = order(rv, decreasing = TRUE)[1:nBest]

rld_top <- rld[select,]

## Perform PCA analysis and make plot
## Get percent of variance explained
data_pcaTop <- plotPCA(rld_top, intgroup = params$design, returnData = TRUE, ntop = nrow(rld_top))
percentVarTop <- round(100 * attr(data_pcaTop, "percentVar"))
highlight_data_pcaTop <- highlight_key(data_pcaTop, ~group)
plot_ly(data = highlight_data_pcaTop,
        x = ~PC1,
        y = ~PC2,
        color = ~group,
        text = ~name,
        type = "scatter") %>%
  layout(xaxis = list(title = paste0("PC1: ", percentVarTop[1] ,"% variance")),
         yaxis = list(title = paste0("PC2: ", percentVarTop[1] ,"% variance")))
```

This plot shows the principal components analysis limited to all DEGs. In this case, the first and second principal component explain `r percentVarTop[1]` and `r percentVarTop[2]` percent of the variance respectively.

# Sample-to-sample distances {.tabset .tabset-fade}

## All `r nrow(assay(rld))` genes, before filtering

```{r 'sampleDist', fig.width = 10, fig.height = 10}
## Obtain the sample euclidean distances
sampleDists <- stats::dist(t(assay(rld)))
sampleDists <- dendextend::sort_dist_mat(sampleDists)
sampleDistMatrix <- as.matrix(sampleDists)

## Add names based on intgroup
# rownames(sampleDistMatrix) <- apply(as.data.frame(colData(rld)[, "original_names"]), 1,
#      paste, collapse = ' : ')
# colnames(sampleDistMatrix) <- apply(as.data.frame(colData(rld)[, "original_names"]), 1,
#      paste, collapse = ' : ')

distances_df <- as.data.frame(colData(rld)[, intgroup, drop = F])
# apply(as.data.frame(colData(rld)[, params$design]), 1, paste, collapse = ' : ')

## Define colors to use for the heatmap
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

## Make the heatmap
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         color = colors,
         annotation_col = distances_df)

```

This plot shows how samples are clustered based on their euclidean distance using the regularized log transformed count data. This figure gives an overview of how the samples are hierarchically clustered. It is a complementary figure to the PCA plot.

## DEGs only (`r length(unique(significantResults[[biomart_filter]]))` genes)

```{r 'sampleDist_degs', fig.width = 10, fig.height = 10}
## Limit to DEGS if any found

if (length(rld_degs_names) > 1) {
  ## Obtain the sample euclidean distances
  sampleDistsDEGs <- stats::dist(t(assay(rld_degs)))
  sampleDistsDEGs <- dendextend::sort_dist_mat(sampleDistsDEGs)
  # sampleDistMatrixTop <- as.matrix(sampleDistsTop)
  sampleDistMatrixDEGs <- as.matrix(sampleDistsDEGs)
  
  ## Add names based on intgroup
  # rownames(sampleDistMatrixDEGs) <- apply(as.data.frame(colData(rld)[, "original_names"]), 1,
  #     paste, collapse = ' : ')
  # colnames(sampleDistMatrixDEGs) <- apply(as.data.frame(colData(rld)[, "original_names"]), 1,
  #     paste, collapse = ' : ')
  
  distances_df <- as.data.frame(colData(rld)[, intgroup, drop = F])
  # apply(as.data.frame(colData(rld)[, params$design]), 1, paste, collapse = ' : ')
  
  ## Define colors to use for the heatmap
  colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
  
  ## Make the heatmap
  pheatmap(sampleDistMatrixDEGs,
           clustering_distance_rows = sampleDists,
           clustering_distance_cols = sampleDists,
           color = colors,
           annotation_col = distances_df)
} else {
  print("No DEGs found.")
}
```

This plot shows how samples are clustered based on their euclidean distance using the regularized log transformed count data of all DEGs. This figure gives an overview of how the samples are hierarchically clustered. It is a complementary figure to the PCA plot.

## Most `r nBest` variable genes only

```{r 'sampleDist_top', fig.width = 10, fig.height = 10}
## Limit to the top n genes
## Using the select object from PCA code above...
## Obtain the sample euclidean distances
sampleDistsTop <- stats::dist(t(assay(rld)[select,]))
sampleDistsTop <- dendextend::sort_dist_mat(sampleDistsTop)
sampleDistMatrixTop <- as.matrix(sampleDistsTop)

## Add names based on intgroup
# rownames(sampleDistMatrixTop) <- apply(as.data.frame(colData(rld)[, "original_names"]), 1,
#     paste, collapse = ' : ')
# colnames(sampleDistMatrixTop) <- apply(as.data.frame(colData(rld)[, "original_names"]), 1,
#     paste, collapse = ' : ')

distances_df <- as.data.frame(colData(rld)[, intgroup, drop = F])
# apply(as.data.frame(colData(rld)[, params$design]), 1, paste, collapse = ' : ')

## Define colors to use for the heatmap
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

## Make the heatmap
pheatmap(sampleDistMatrixTop,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         color = colors,
         annotation_col = distances_df)
```

This plot shows how samples are clustered based on their euclidean distance using the regularized log transformed count data of the top `r nBest` most variable genes. This figure gives an overview of how the samples are hierarchically clustered. It is a complementary figure to the PCA plot.

# Heatmaps {.tabset .tabset-fade}

```{r 'heatmaps_shared_code'}
heatmap_df <- as.data.frame(colData(rld)[, intgroup, drop = F]) # Used for other heatmaps too
row.names(heatmap_df) <- colData(rld)$original_names # Customize!
get_clean_names <- function(vector_of_names) {
  hm_names <- data.frame(genes = vector_of_names)
  names(hm_names)[names(hm_names) == "genes"] <- biomart_filter
  heatmap_annotation_table <- allResults %>%
    dplyr::select(!!ensym(biomart_filter),
                  !!ensym(species_gene_symbol))
  hm_names <- dplyr::left_join(hm_names,
                               heatmap_annotation_table,
                               by = biomart_filter) %>%
    dplyr::distinct() %>%
    dplyr::group_by(!!ensym(biomart_filter)) %>%
    # May be tricky to determine if more than one gene should be combined in a row.
    # Instead, currently using first non-NA value, since it's possible to have NAs sneak in
    # particularly at this point... high variance genes might not be picked up as DEGs.
    #dplyr::mutate(combined = paste0(!!ensym(species_gene_symbol), collapse = ", ")) %>%
    dplyr::mutate(combined = coalesce(!!ensym(species_gene_symbol), !!ensym(biomart_filter))) %>%
    dplyr::select(-!!ensym(species_gene_symbol)) %>%
    slice(1) %>% # This is bit of a hack - ran into problems with TempO-Seq probes that map to multiple genes.
    dplyr::distinct()
  hm_names <- hm_names[match(vector_of_names, hm_names[[biomart_filter]]), ]
  hm_names <- hm_names %>% dplyr::pull(combined)
  return(hm_names)
}

```

## All `r length(unique(significantResults[[biomart_filter]]))` DEGs

```{r 'heatmap_all_DEGs', collapse = TRUE, fig.height = 10}

mat <- assay(rld)[row.names(assay(rld)) %in%
                                          significantResults[[biomart_filter]],
                  , drop = F] # Otherwise will return numeric for 1 row matrix
if (nrow(as.matrix(mat)) > 1) {
  mat <- mat - rowMeans(mat)
  pheatmap(mat,
           annotation_col = heatmap_df,
           show_rownames = FALSE,
           border_color = NA,
           scale = "row")
  # color = inferno(10)
} else {
  print("No DEGs found.")
}
```

## Top `r nHeatmapDEGs` differentially abundant genes

```{r 'heatmap_top_degs', fig.height = 10, fig.width = 10, collapse = TRUE}
mat_top <- assay(rld)[row.names(assay(rld)) %in% allResultsOrdered_logFC_filter[1:nHeatmapDEGs,][[biomart_filter]],
                      , drop = F]
if (nrow(as.matrix(mat_top)) > 1) {
  mat_top <- mat_top - rowMeans(mat_top)
  genes_for_heatmap <- get_clean_names(row.names(mat_top))
  pheatmap(mat_top,
           annotation_col = heatmap_df,
           labels_row = genes_for_heatmap,
           show_rownames = TRUE,
           border_color = NA,
           scale = "row")
  # color = inferno(10)
} else {
  print("No DEGs found.")
}
```

## Top `r nHeatmap` variable genes

```{r 'heatmap_top_n_genes', fig.height = 10, fig.width = 10, collapse = TRUE}
rv = rowVars(assay(rld))
select = order(rv, decreasing = TRUE)[1:nHeatmap]
matRV <- assay(rld)[select,]
matRV <- matRV - rowMeans(matRV)
genes_for_heatmap <- get_clean_names(row.names(matRV))

cutree_rows <- 3
cutree_cols <- 4

if(nrow(heatmap_df) < 5){
  cutree_cols <- 2
}

pheatmap(matRV,
         #color = rev(brewer.pal(11, "RdBu")), # inferno(10),
         annotation_col = heatmap_df,
         labels_row = genes_for_heatmap,
         border_color = NA,
         scale = "row",
         cutree_rows = cutree_rows,
         cutree_cols = cutree_cols)

```


# MA plots

This section contains three groups of MA plots (see [Wikipedia](https://en.wikipedia.org/wiki/MA_plot)) that compare the mean of the normalized counts against the log fold change. Each of the groups has a tab for each contrast. The plots show one point per feature. The points are shown in red if the feature has an adjusted p-value less than the cutoff listed in each section, that is, the statistically significant features are shown in red.

## Filtered at `r metadata(resListAll[[1]])$alpha` {.tabset .tabset-fade}

This group of plots shows `alpha` = `r metadata(resListAll[[1]])$alpha`, which is the `alpha` value used to determine which resulting features were significant when running the function `DESeq2::results()`.  

```{r fc_range, warning = FALSE}
# Find IQR for absolute values of all significant log2foldchanges
# Plot MA plots
foldchangestats <- boxplot(abs(allResults$log2FoldChange), plot = F)
ylims_for_ma_plots <- c(-foldchangestats$stats[4, 1], foldchangestats$stats[4, 1])
```

```{r 'MAplotalpha', results='asis'}
## MA plot with alpha used in DESeq2::results()

for (i in seq_along(resListAll)) {
  contrast = gsub(pattern = paste0("log2.*", DESIGN, "\ "),
                  replacement =  "",
                  x = resListAll[[i]]@elementMetadata[[2]][2])
  cat("###", contrast, "  \n\n")
  MA_title <- paste0('MA plot, alpha = ', metadata(resListAll[[i]])$alpha,', ', contrast)
  DESeq2::plotMA(resListAll[[i]],
                 alpha = metadata(resListAll[[i]])$alpha,
                 main = str_wrap(MA_title, width = 40),
                 ylim = ylims_for_ma_plots)
  cat('  \n\n')
}

## Used to have multiple tabsets for MA plots... it was too many MA plots.

## MA plot with alpha = 1/2 of the alpha used in DESeq2::results()
# for (i in 1:length(resList)) {
# contrast = gsub(pattern = "log2.*Time\ ",
#                 replacement =  "",
#                 x = resListSig[[i]]@elementMetadata[[2]][2])
# cat("###", contrast, " \n")
# DESeq2::plotMA(resListSig[[i]], alpha = metadata(resListSig[[i]])$alpha / 2,
#     main = paste('MA plot with alpha =', metadata(resListSig[[i]])$alpha / 2,',', contrast))
# cat('\n\n')
# }

## MA plot with alpha corresponding to the one that gives the nBest features
# for (i in 1:length(resList)) {
# nBest.actual <- min(nBest, nrow(head(resListSig[[i]], n = nBest)))
# nBest.alpha <- head( resListSig[[i]][order(resListSig[[i]]$pvalue),], n = nBest)$padj[nBest.actual]
# contrast = gsub(pattern = "log2.*Time\ ",
#                 replacement =  "",
#                 x = resListSig[[i]]@elementMetadata[[2]][2])
# cat("###", contrast, " \n")
# DESeq2::plotMA(resListSig[[i]], alpha = nBest.alpha * 1.00000000000001,
#     main = paste('MA plot for top', nBest.actual, 'features',',', contrast))
# cat('\n\n')
# }

```

## {-}

# P-values {.tabset .tabset-fade}

## Distribution of all p-values

```{r pvalueHistogram, collapse = TRUE}
## P-value histogram plot

ggplot(allResults, aes(x = pvalue)) +
    geom_histogram(alpha = .5, position = 'identity', bins = 50) +
    labs(title = 'Histogram of unadjusted p-values') +
    xlab('Unadjusted p-values') +
    facet_wrap( ~ contrast, ncol = 2)

```

This plot shows a histogram of the unadjusted p-values. It might be skewed right or left, or flat as shown in the [Wikipedia examples](https://en.wikipedia.org/wiki/Histogram#Examples). The shape depends on the percent of features that are differentially expressed. For further information on how to interpret a histogram of p-values check [David Robinson's post on this topic](http://varianceexplained.org/statistics/interpreting-pvalue-histogram/).

```{r pvalueSumm}
## P-value distribution summary
summary(allResults$pvalue)
#boxplot(allResults$pvalue)
```

This is the numerical summary of the distribution of the p-values.

```{r pvalueTable, results = 'asis'}
## Split features by different p-value cutoffs
pval_table <- lapply(c(1e-04, 0.001, 0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5,
    0.6, 0.7, 0.8, 0.9, 1), function(x) {
    data.frame('Cut' = x, 'Count' = sum(allResults$pvalue <= x, na.rm = TRUE))
})
pval_table <- do.call(rbind, pval_table)
kable(pval_table, format = 'markdown', align = c('c', 'c'))
```

This table shows the number of features with p-values less or equal than some commonly used cutoff values. 

## Distribution of adjusted p-values

```{r padjHistogram, collapse = TRUE}
## Adjusted p-values histogram plot
ggplot(allResults, aes(x = padj)) +
  geom_histogram(alpha = 0.5, position = 'identity', bins = 50) +
  labs(title = paste('Histogram of', elementMetadata(resListSig[[1]])$description[grep('adjusted', elementMetadata(resListSig[[1]])$description)])) +
  xlab('Adjusted p-values') +
  facet_wrap( ~ contrast, ncol = 2)
```

This plot shows a histogram of the `r elementMetadata(resListSig[[1]])$description[grep('adjusted', elementMetadata(resListSig[[1]])$description)]`. It might be skewed right or left, or flat as shown in the [Wikipedia examples](https://en.wikipedia.org/wiki/Histogram#Examples). 

```{r padjSumm}
## Adjusted p-values distribution summary
summary(res.df$padj)
```

This is the numerical summary of the distribution of the `r elementMetadata(resListSig[[1]])$description[grep('adjusted', elementMetadata(resListSig[[1]])$description)]`.

```{r padjTable, results = 'asis'}
## Split features by different adjusted p-value cutoffs
padj_table <- lapply(c(1e-04, 0.001, 0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5,
    0.6, 0.7, 0.8, 0.9, 1), function(x) {
    data.frame('Cut' = x, 'Count' = sum(res.df$padj <= x, na.rm = TRUE))
})
padj_table <- do.call(rbind, padj_table)
kable(padj_table, format = 'markdown', align = c('c', 'c'))
```

This table shows the number of features with `r elementMetadata(resListSig[[1]])$description[grep('adjusted', elementMetadata(resListSig[[1]])$description)]` less or equal than some commonly used cutoff values. 

# Tables of top features

This table shows the significant DEGs (passing all filtering criteria) ordered by their absolute fold change. Use the search function to find your feature of interest or sort by one of the columns. You can limit to a single contrast if desired.

```{r 'topFeatures', results = 'asis', warning = FALSE}
searchURL <- "http://www.ncbi.nlm.nih.gov/gene/?term="
## Add search url if appropriate
res.df.dt <- res.df
if (!is.null(searchURL)) {
    res.df.dt$Gene <- paste0('<a href="',
                             searchURL,
                             res.df.dt$ensembl_gene_id,
                             '" rel="noopener noreferrer" target="_blank">',
                             res.df.dt$ensembl_gene_id,
                             '<br/>',
                             res.df.dt[[species_gene_symbol]],
                             '</a>')
    res.df.dt <- res.df.dt %>% dplyr::relocate(Gene)
}

res.df.dt[, 'padj'] <- format(res.df.dt[, 'padj'],
                              scientific = TRUE,
                              digits = digits)
res.df.dt[, 'pvalue'] <- format(res.df.dt[, 'pvalue'],
                                scientific = TRUE,
                                digits = digits)
res.df.dt <- res.df.dt %>%
  dplyr::select(-c(!!ensym(species_gene_symbol), !!ensym(biomart_filter), ensembl_gene_id))

DT::datatable(res.df.dt,
          options = list(pagingType = 'full_numbers',
                         pageLength = 20,
                         scrollX = '100%',
                         dom = 'Bfrtip',
                         buttons = c('copy',
                                     'csv',
                                     'excel',
                                     'pdf',
                                     'print',
                                     'colvis'),
                         columnDefs = list(list(visible = FALSE, targets = c(2, 4, 5)))),
          escape = FALSE,
          extensions = 'Buttons',
          rownames = FALSE,
          filter = "top",
          # colnames = c('Gene' = 'ensembl_gene_id') # hopefully don't need this now...
          ) %>% 
  DT::formatRound(which(!colnames(res.df.dt) %in% c('pvalue',
                                                    'padj',
                                                    'Feature',
                                                    'contrast',
                                                    'description',
                                                    'Gene',
                                                    'external_gene_name')),
                  digits)

```


```{r 'bmdexpress_input', collapse = TRUE}

###########################################################################################
######## PRODUCE INPUT FOR BMDExpress2 ####################################################
###########################################################################################
# Run this code conditional on whether there is a column matching the word dose in the metadata

# Compile list of filtered genes
genes_filtered <- lapply(resListFiltered,
                         function(x) row.names(as.data.frame(x)))
genes_filtered <- unlist(genes_filtered) %>% unique()

# This should give an idea of which genes were observed in n contrasts.
# ODAFResults %>% count(PROBE_NAME)


if (!is.na(params$dose)) {
  # Create input file...
  read.counts <- as.data.frame(counts(dds, normalized = TRUE))
  lognorm.read.counts <- log2(read.counts + 1)
  bmdexpress <- as.data.frame(lognorm.read.counts)
  bmdexpress <- cbind(SampleID = c(row.names(bmdexpress)),
                      bmdexpress,
                      stringsAsFactors = F)
  bmdexpress <- rbind(c("Dose", as.character(DESeqDesign[colnames(bmdexpress)[-1],][[params$dose]])),
                      bmdexpress,
                      stringsAsFactors = F)
  biomarkers <- bmdexpress # Still includes all genes
  bmdexpress <- rbind(bmdexpress[1,], bmdexpress[genes_filtered,]) # Remove low-quality genes
  if (!is.na(params$group_facet)) {
    fname <- paste0("bmdexpress_input_",
                    paste(params$group_filter,
                          collapse = "_"),
                    ".txt")
    fname2 <- paste0("biomarker_input_",
                    paste(params$group_filter,
                          collapse = "_"),
                    ".txt")
    write.table(bmdexpress,
                file = file.path(paths$BMD_output,
                                 fname),
                quote = F,
                sep = "\t",
                row.names = F,
                col.names = T)
    write.table(biomarkers,
                file = file.path(paths$BMD_output,
                                 fname2),
                quote = F,
                sep = "\t",
                row.names = F,
                col.names = T)
  } else {
    write.table(bmdexpress,
                file = file.path(paths$BMD_output, "bmdexpress_input.txt"),
                quote = F,
                sep = "\t",
                row.names = F,
                col.names = T)
    write.table(biomarkers,
                file = file.path(paths$BMD_output, "biomarkers_input.txt"),
                quote = F,
                sep = "\t",
                row.names = F,
                col.names = T)
  }
}
```


# Gene-level plots for top `r nBestFeatures` features

This section contains plots showing the normalized counts per sample for each group of interest. Only the best `r nBestFeatures` features are shown, ranked by their absolute fold change values. The Y axis is on the log10 scale and the feature name is shown in the title of each plot.

```{r 'plotCounts'}
# Would be valuable to have this broken down by contrast too.
plotCounts_gg <- function(i, dds, intgroup) {
    plotdata <- plotCounts(dds,
                       gene = i,
                       intgroup = intgroup,
                       returnData = TRUE)
    plot_title <- paste(id_table[[biomart_filter]][grep(i,id_table[[biomart_filter]])],
                        id_table[[species_gene_symbol]][grep(i, id_table[[biomart_filter]])])
    if (ncol(plotdata) > 2) {
      colorCol = 3
    } else {colorCol = 2}
    ggplot(plotdata, aes(x = plotdata[, 2], y = plotdata[, 1], color = plotdata[, colorCol])) + 
      geom_point(position = position_jitterdodge()) +
      ylab('Normalized count') +
      xlab('Group') +
      ggtitle(plot_title) +
      coord_trans(y = "log10") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
      labs(color = colnames(plotdata)[colorCol])
}

genesToPlot <- significantResults %>% arrange(-abs(log2FoldChange))

for (i in head(unique(genesToPlot[[biomart_filter]]), nBestFeatures)) {
  print(plotCounts_gg(i, dds = dds, intgroup = params$design))
}

# Make a table of counts
counts_by_group <- as.data.frame(counts(dds, normalized = TRUE))
counts_by_group <- as.data.frame(counts_by_group)
# counts_by_group <- log2(counts_by_group + 1) # Optional
# Add gene name
counts_by_group$gene <- row.names(counts_by_group)
# Clean up table, make into long format for plotting
counts_by_group <- counts_by_group %>%
  pivot_longer(!gene,
               names_to = "Sample",
               values_to = "Normalized Counts")

# Annotate table with experimental group of interest (params$design)
counts_by_group <- counts_by_group %>%
  left_join(DESeqDesign %>% dplyr::select(c(!!sym(params$design),original_names)),
            by = c("Sample" = "original_names"))
names(counts_by_group)[4] <- "group"

# Filter by absolute fold change to include a reasonable number of genes
genesToSelect <- allResults %>%
  arrange(-abs(log2FoldChange)) %>%
  head(1000) # Seems to be a reasonable maximum...

# Order by alphabet to help readability in dropdown menu
genesAlphabetized <- genesToSelect %>%
  dplyr::arrange(-abs(log2FoldChange)) %>%
  dplyr::arrange(!!ensym(biomart_filter))

# Get the data 
counts_by_group <- counts_by_group %>%
  dplyr::filter(gene %in% genesAlphabetized[[biomart_filter]])

# Create "shared" data object - this is for enabling live filtering
counts_by_group_shared <- SharedData$new(counts_by_group)

# Make an initial filter using the top gene
top_gene = genesToSelect[[biomart_filter]][1]
i = as.character(which(counts_by_group$gene == top_gene))

# Make a "transceiver" to set initial state of filter
tx = crosstool(counts_by_group_shared,
               "transceiver",
               init = i,
               channel = "filter",
               reset = rownames(counts_by_group))

# Plot interactive plotly with filter on gene name
bscols(widths = c(2,NA),
  list(
    filter_select("gene_to_filter",
                  "Gene",
                  counts_by_group_shared,
                  ~gene,
                  unique(genesAlphabetized[[biomart_filter]]),
                  multiple = F)
  ),
  list(
    plot_ly(data = counts_by_group_shared,
            x = ~group,
            y = ~`Normalized Counts`,
            color = ~group,
            type = "box",
            boxpoints = "all",
            jitter = 0.6,
            pointpos = 0,
            text = ~Sample,
            boxmean = T) %>%
      layout(xaxis = list(title = ''), 
             yaxis = list(title = 'Normalized Counts'),
             legend = list(title = list(text = '<b> Experimental Group </b>'))) %>%
      add_annotations(
        text = "Gene",
        x = 0.5, y = 1,
        xref = "paper", yref = "paper",
        xanchor = "center", yanchor = "bottom",
        showarrow = FALSE
      ),
    tx)
)

# This works interactively but is NOT compatible with RMarkdown, unfortunately.
# plotCounts_plotly <- function(i, dds, intgroup) {
#     plotdata <- plotCounts(dds,
#                        gene = i,
#                        intgroup = intgroup,
#                        returnData = TRUE)
#     plot_title <- paste(id_table[[biomart_filter]][id_table[[biomart_filter]] == i],
#                         id_table[[species_gene_symbol]][id_table[[biomart_filter]] == i])
#     if (ncol(plotdata) > 2) {
#       colorCol = 3
#     } else {colorCol = 2}
#     plot_ly(data = plotdata,
#             x = ~group,
#             y = ~count,
#             type = "box",
#             boxpoints = "all",
#             jitter = 0.6,
#             pointpos = 0)
# }
# 
# manipulate_plotCounts <- function(genes) {
#   plotCounts_plotly(genes, dds, params$design)
# }
# 
# geneplot_widget <- manipulateWidget(
#   manipulate_plotCounts(genes),
#   genes = mwSelectize(unique(genesAlphabetized[[biomart_filter]]),
#                    label = "Top 1000 Genes by Fold Change (including those filtered out)",
#                    list(maxItems = 20000), # This doesn't expand past an apparently undocumented number... That is, the dropdown won't display all the items.
#                    .display = T)
# )
# 
# # Ok, this is not great because it would only save a single plot to the HTML file.
# # Not quite what I need.
# htmlwidgets::saveWidget(geneplot_widget, file = "test.html")

```

# Plots of genes of interest

This section shows genes of interest sorted by those with highest fold-change within each contrast.

```{r 'plot_genes_of_interest', fig.width = 10, fig.height = 6, eval = nrow(allResultsOrdered_logFC_filter) > 0}

#numResults = 20
numResults <- nBestFeatures

allResultsOrdered_logFC_filter %>%
  group_by(contrast) %>%
  top_n(numResults, wt = abs(log2FoldChange)) %>%
  ungroup() %>%
  mutate(contrast = as.factor(contrast),
         symbol = reorder_within(!!ensym(species_gene_symbol), log2FoldChange, contrast)) %>%
  ggplot(aes(x = log2FoldChange,
             y = symbol,
             color = contrast,
             size = -log(padj))) +
  geom_point(show.legend = TRUE) +
  facet_wrap(~contrast,
             scales = "free_y",
             ncol = 4,
             labeller = labeller(contrast = label_wrap_gen(10))) +
  scale_y_reordered()  +
  geom_vline(xintercept = 0,
             linetype = "dashed",
             color = "black",
             size = 1) +
  ggtitle(paste0("Top ",
                 numResults,
                 " genes ranked by fold change (adjusted p-value <",
                 alpha,
                 "), grouped by treatment"))
```

# Volcano plots

This section shows a volcano plot for each contrast.  

The tabs show each contrast interactively.

## All data

Note that scales are set manually for this plot: therefore, there may be data points outside the range shown (see warnings).  

Data reported as significant are shown as red points.

```{r 'volcano-plot', fig.width = 8, fig.height = 6, warning = TRUE, collapse = TRUE}
ggplot(allResults, aes(x = log2FoldChange, y = -log10(padj))) +
  geom_point(size = 0.5, alpha = 0.3) +
  geom_point(data = significantResults, size = 0.5, alpha = 0.9, color = "red", text = species_gene_symbol) +
  geom_vline(xintercept = c(-log2(1.5), log2(1.5)), color = "red", alpha = 1.0) + 
  geom_hline(yintercept = -log10(0.05), color = "blue", alpha = 1.0) +
  scale_x_continuous(name = "log2 Fold Change", limits = c(-5, 5)) +
  scale_y_continuous(name = "-log10 adjusted p-value", limits = c(0, 6)) + 
  facet_wrap(~contrast, ncol = 4, labeller = labeller(
    .default = label_wrap_gen(15)))
```

## By contrast

```{r plotly_volcanos}
volcano_df <- as.data.frame(allResults) %>%
  dplyr::select(c(biomart_filter,
                  species_gene_symbol,
                  "log2FoldChange",
                  "linearFoldChange",
                  "padj","contrast")) %>%
  distinct()
volcano_df_sig <- as.data.frame(significantResults)
volcano_df["sig_group"] <- "Not significant"
  volcano_df[which(volcano_df['padj'] < alpha &
                     abs(volcano_df['linearFoldChange']) < linear_fc_filter ),
             "sig_group"] <- paste0("FDR >", alpha)
  volcano_df[which(volcano_df['padj'] > alpha &
                     abs(volcano_df['linearFoldChange']) > linear_fc_filter ),
             "sig_group"] <- paste0("Linear fold change >", linear_fc_filter)
  volcano_df[!is.na(volcano_df[['padj']]) &
               abs(volcano_df['linearFoldChange']) > linear_fc_filter &
               volcano_df['padj'] < alpha &
               volcano_df[[biomart_filter]] %in% volcano_df_sig[[biomart_filter]],
             "sig_group"] <- "Passed all filters"
  
volcano_df_shared <- SharedData$new(volcano_df)
volcano_contrasts <- unique(allResults$contrast)

contrast_init = volcano_contrasts[1]
i = as.character(which(volcano_df$contrast == contrast_init))

# Make a "transceiver" to set initial state of filter
tx = crosstool(volcano_df_shared,
               "transceiver",
               init = i,
               channel = "filter",
               reset = rownames(volcano_df))

# Plot interactive plotly with filter on gene name
bscols(widths = c(3,NA),
  list(
    filter_select("contrast_to_filter",
                  "Contrast",
                  volcano_df_shared,
                  ~contrast,
                  volcano_contrasts,
                  multiple = F)
  ),
  list(
    plot_ly(data = volcano_df_shared,
            x = ~log2FoldChange,
            y = ~-log10(padj),
                             type = 'scatter',
                             mode = 'markers',
                             color = ~sig_group,
                             text = formula(paste0(paste0("~"),
                                                   paste0(species_gene_symbol)))) %>%
    layout(xaxis = list(title = 'log2 Fold Change'),
           yaxis = list(title = '-log10 adjusted p-value')),
    # How to add title that gets updated??? Same problem with gene plots.
    tx)
)
```



# GO Enrichment Analysis {.tabset .tabset-fade}

This section performs GO enrichment on **all DEGs passing filters**. The background set of genes is those that were identified in this sequencing experiment. The [clusterProfiler](https://bioconductor.org/packages/release/bioc/html/clusterProfiler.html) package is used for this analysis.

```{r cluster-profiler, warning = FALSE, message = FALSE, collapse = TRUE}
## Remember that dds had ENSEMBL ids for the genes
# ensemblNames <- gsub("\\..*", "", rownames(dds))

ensemblDEGs <- significantResults[[biomart_filter]]
head(ensemblDEGs)
DEGs <- dplyr::left_join(data.frame(genes = ensemblDEGs), id_table_entrez, by = c("genes" = biomart_filter))
head(DEGs)
entrezDEGs <- as.character(DEGs$entrezgene_id)
entrezDEGs <- entrezDEGs[!is.na(entrezDEGs)] %>% unique()

#### DEFINE INPUTS
myDEGs <- entrezDEGs
# background <- row.names(assay(dds))
background <- dplyr::left_join(data.frame(genes = row.names(assay(dds))),
                               id_table_entrez,
                               by = c("genes" = biomart_filter)) %>%
  dplyr::filter(!is.na(entrezgene_id)) %>%
  dplyr::pull(entrezgene_id)
background <- as.character(background)

##### TO DO: Add multiple panels for each contrast.
##### Use "all" argument to only run each once..?

## Not all genes have a p-value
table(!is.na(resListSig[[1]]$padj))

KeyType <- "ENTREZID" # ENSEMBL? ACCNUM? GID? ENTREZID?
# head(keys(orgdb, keytype = "ENTREZID"))

# Run all at once...
# enrich_go_all <- enrichGO(gene = myDEGs,
#                          universe = background, # All genes in dataset
#                          OrgDb = orgdb,
#                          keyType = KeyType,
#                          readable = T,
#                          ont = "all",
#                          pAdjustMethod = "BH",
#                          pvalueCutoff = 0.01,
#                          qvalueCutoff = 0.05)

# clusterProfiler::dotplot(enrich_go_all, font.size = 9, showCategory = 10, split = "ONTOLOGY")  +
#   theme(axis.text.y = element_text(angle = 0)) +
#   scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 50)) +
#   facet_wrap(~ONTOLOGY)

## Can also do individually...
## Perform enrichment analysis for Biological Process (BP)
enrich_go_bp <- enrichGO(gene = myDEGs,
                         universe = background, # All genes in dataset
                         OrgDb = orgdb,
                         keyType = KeyType,
                         readable = T,
                         ont = "BP",
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.01,
                         qvalueCutoff = 0.05)

enrich_go_mf <- enrichGO(gene = myDEGs,
                         universe = background, # All genes in dataset
                         OrgDb = orgdb,
                         keyType = KeyType,
                         readable = T,
                         ont = "MF",
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.01,
                         qvalueCutoff = 0.05)

enrich_go_cc <- enrichGO(gene = myDEGs,
                         universe = background, # All genes in dataset
                         OrgDb = orgdb,
                         keyType = KeyType,
                         ont = "CC",
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.01,
                         qvalueCutoff = 0.05)

write.table(as.data.frame(enrich_go_bp),
            file = file.path(paths$pathway_analysis, "Enriched.GO_terms.Biological_Processes.txt"))
write.table(as.data.frame(enrich_go_mf),
            file = file.path(paths$pathway_analysis, "Enriched.GO_terms.Molecular_Functions.txt"))
write.table(as.data.frame(enrich_go_cc),
            file = file.path(paths$pathway_analysis, "Enriched.GO_terms.Cellular_Component.txt"))

```

## Biological processes

```{r calculate-foldchanges, message = FALSE, warning = FALSE}
  DEGs_full <- dplyr::left_join(significantResults,
                                id_table_entrez,
                                by = biomart_filter) %>%
    distinct()
  foldChanges <- DEGs_full %>% dplyr::pull(log2FoldChange)
  names(foldChanges) <- DEGs_full %>% dplyr::pull(entrezgene_id)
  foldChanges <- foldChanges %>% sort() %>% rev()
  foldChanges <- foldChanges[!is.na(names(foldChanges))]
```

```{r plot_GO_analysis_bp, warning = FALSE, fig.width = 12, collapse = TRUE}
if (!is.null(enrich_go_bp)) {
  if (nrow(enrich_go_bp@result %>% filter(p.adjust < 0.01 & qvalue < 0.05)) > 3) {
    plot1 <- clusterProfiler::dotplot(enrich_go_bp, font.size = 9, showCategory = 20)  +
      theme(axis.text.y = element_text(angle = 0)) +
      scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))

    simplified_bp <- simplify(enrich_go_bp, cutoff = 0.7, by = "p.adjust", select_fun = min)
    # Max size of gene set... useful for visualizing networks
    simplified_bp_for_network <- simplified_bp %>% DOSE::gsfilter(by = "GSSize", max = 400)
    # I believe there is a bug in the current version of DOSE or clusterProfiler that prevents this from working
    # Throws this error on plotting: Error in graph.data.frame(x, directed = FALSE) : the data frame should contain at least two columns
    simplified_bp_filt <- simplified_bp %>%
      filter(p.adjust < .05, qvalue < 0.05) %>%
      mutate(GeneRatio = DOSE::parse_ratio(GeneRatio)) %>%
      arrange(desc(GeneRatio))

    if (nrow(as.data.frame(simplified_bp_filt)) < 10) {
        show_num <- simplified_bp_filt$Description # Top N less than 10
      } else {
        show_num <- simplified_bp_filt$Description[1:10] # Top 10
      }
    
    plot2 <- cnetplot(simplified_bp,
                      foldChange = foldChanges,
                      showCategory = show_num,
                      cex_label_gene = 0.3)
    
    plot3 <- upsetplot(enrich_go_bp)
    plot4 <- heatplot(simplified_bp, foldChange = foldChanges, showCategory = show_num) +
      scale_y_discrete(labels = function(x) stringr::str_trunc(x, width = 50))
    
    print(plot1)
    print(plot2)
    print(plot3)
    print(plot4)
  } else {
    num_terms <- nrow(enrich_go_bp@result %>% filter(p.adjust < 0.01 & qvalue < 0.05))
    cat(paste0(num_terms," enriched terms found. This is not enough to report in the results."))
  }
} else { cat("No significantly enriched terms using criteria selected") }
```

## Molecular Functions

```{r plot_GO_analysis_mf, warning = FALSE, fig.width = 12, collapse = TRUE}
if (!is.null(enrich_go_mf)) {
  
  if (nrow(enrich_go_mf@result %>% filter(p.adjust < 0.01 & qvalue < 0.05)) > 3) {
    plot1 <- clusterProfiler::dotplot(enrich_go_mf, font.size = 9)  +
      theme(axis.text.y = element_text(angle = 0)) +
      scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))
    
    simplified_mf <- simplify(enrich_go_mf, cutoff = 0.7, by = "p.adjust", select_fun = min)
    # Max size of gene set... useful for visualizing networks
    simplified_mf_for_network <- simplified_mf %>% DOSE::gsfilter(by = "GSSize", max = 400)
    # I believe there is a bug in the current version of DOSE or clusterProfiler that prevents this from working
    # Throws this error on plotting: Error in graph.data.frame(x, directed = FALSE) : the data frame should contain at least two columns
    simplified_mf_filt <- simplified_mf %>%
      filter(p.adjust < .05, qvalue < 0.05) %>%
      mutate(GeneRatio = DOSE::parse_ratio(GeneRatio)) %>%
      arrange(desc(GeneRatio))
    
    if (nrow(as.data.frame(simplified_mf)) < 10) {
        show_num <- simplified_mf_filt$Description # Top N less than 10
      } else {
        show_num <- simplified_mf_filt$Description[1:10] # Top 10
      }
    
    if (nrow(simplified_mf) > 3) {
      plot2 <- cnetplot(simplified_mf,
                        foldChange = foldChanges,
                        showCategory = show_num,
                        cex_label_gene = 0.3)
    }
    
    enrich_go_mf_upset <- enrich_go_mf
    enrich_go_mf_upset@result$Description <- str_trunc(enrich_go_mf_upset@result$Description, width = 50)
    plot3 <- upsetplot(enrich_go_mf_upset)
    plot4 <- enrichplot::heatplot(simplified_mf, foldChange = foldChanges, showCategory = show_num) +
      scale_y_discrete(labels = function(x) stringr::str_trunc(x, width = 50))
    
    print(plot1)
    if (nrow(simplified_mf) > 3) {print(plot2)} else {print("Network plot not shown due to a limited number of enriched terms.")}
    print(plot3)
    print(plot4)
  } else {
    num_terms <- nrow(enrich_go_mf@result %>% filter(p.adjust < 0.01 & qvalue < 0.05))
    cat(paste0(num_terms," enriched terms found. This is not enough to report in the results."))
  }
} else {cat("No significantly enriched terms using criteria selected") }
```

## Cellular Component

```{r plot_GO_analysis_cc, warning = FALSE, fig.width = 12, collapse = TRUE}
if (!is.null(enrich_go_cc)) {
  if (nrow(enrich_go_cc@result %>% filter(p.adjust < 0.01 & qvalue < 0.05)) > 3) {
    plot1 <- clusterProfiler::dotplot(enrich_go_cc, font.size = 9)  +
      theme(axis.text.y = element_text(angle = 0)) +
      scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))
    
    simplified_cc <- simplify(enrich_go_cc, cutoff = 0.7, by = "p.adjust", select_fun = min)
    # Max size of gene set... useful for visualizing networks
    simplified_cc_for_network <- simplified_cc %>% DOSE::gsfilter(by = "GSSize", max = 400)
    # I believe there is a bug in the current version of DOSE or clusterProfiler that prevents this from working
    # Throws this error on plotting: Error in graph.data.frame(x, directed = FALSE) : the data frame should contain at least two columns
    simplified_cc_filt <- simplified_cc %>%
      filter(p.adjust < .05, qvalue < 0.05) %>%
      mutate(GeneRatio = DOSE::parse_ratio(GeneRatio)) %>%
      arrange(desc(GeneRatio))

    if (nrow(as.data.frame(simplified_cc_filt)) < 10) {
      show_num <- simplified_cc_filt$Description # Top N less than 10
      } else {
        show_num <- simplified_cc_filt$Description[1:10] # Top 10
      }
    
    plot2 <- cnetplot(simplified_cc,
                      foldChange = foldChanges,
                      showCategory = show_num,
                      cex_label_gene = 0.3)
    
    enrich_go_cc_upset <- enrich_go_cc
    enrich_go_cc_upset@result$Description <- str_trunc(enrich_go_cc_upset@result$Description, width = 50)
    plot3 <- upsetplot(enrich_go_cc_upset)
    plot4 <- enrichplot::heatplot(simplified_cc, foldChange = foldChanges, showCategory = show_num) +
      scale_y_discrete(labels = function(x) stringr::str_trunc(x, width = 50))
    
    print(plot1)
    print(plot2)
    print(plot3)
    print(plot4)
  } else {
    num_terms <- nrow(enrich_go_cc@result %>% filter(p.adjust < 0.01 & qvalue < 0.05))
    cat(paste0(num_terms," enriched terms found. This is not enough to report in the results."))
  }
} else {cat("No significantly enriched terms using criteria selected")}
```

```{r run_pathway_analysis_child_document, child = pathway_analysis, eval = params$run_pathway_analysis & length(entrezDEGs) > 1 & nrow(significantResults) > 0}
```

# Methods Summary

Please use this as a starting point for the bioinformatics/statistics section of any publications based on the data analyzed in this report. All of the information provided here is contained elsewhere in the report, but it is aggregated here for your convenience.  

There were `r samples_before` samples for which data was collected. A count matrix containing the $`r initialSampleDataCount`$ samples sequenced in this experiment was imported into R for statistical analysis. After removing samples with less than $`r threshold`$ reads, `r filteredSampleDataCount` samples were left. Following the exclusion of other samples *(which ones? Why? Please explain for your experiment, if applicable.)*, there were `r samples_after` samples remaining. Following the recommendations set out by the Omics Data Analysis Frameworks for Regulatory application (R-ODAF) guidelines, genes were filtered to include only those where 75% of at least one experimental group were above `r MinCount` CPM, and spurious spikes were removed in which (max - median) of counts were less than (sum of counts)/(number of replicates + 1). The samples excluded from analysis are shown in the table below. We used DESeq2 `r packageVersion("DESeq2")` [@pmid:25516281] to test for differentially abundant genes within the `r Platform` data. The log2FoldChange shrinkage procedure used was `r resListSig[[1]]@priorInfo$type`. An alpha of `r resListSig[[1]]@metadata$alpha` was used to extract raw results, which are reported as the `r gsub(mcols(x=resListSig[[1]])$description[[4]],pattern=":.*",replacement="")`. To account for multiple testing, `r mcols(resListSig[[1]])$description[5]` are reported. Cook's cutoff was set to `r cooks` in this analysis. Differentially expressed genes (DEGs) were filtered using a linear fold change cutoff of `r linear_fc_filter` and adjusted p-value of `r alpha`.  

## References {-}

If these methods were used in your study, please cite the following papers as appropriate:  

---
nocite: '@*'
---

<div id="refs"></div>

# Session Info

## Date the report was generated.

```{r reproducibility1, echo = FALSE}
## Date the report was generated
Sys.time()
```

## Version of R-ODAF Repository

The git hash for the commit of the [R-ODAF repository](`r system("git remote get-url origin", intern = T)`) used in this analysis is `r system("git rev-parse HEAD", intern = T)`.

## Parameters Used

From the list elements in each params${variable} used to generate this report.

```{r paramsList, echo = FALSE}
df <- as.data.frame(unlist(params))
names(df) <- "Parameter Value"
knitr::kable(as.data.frame(df), format = "markdown")
```

## Wallclock time spent generating the report.

```{r reproducibility2, echo = FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits = 3)
```

## `R` session information.

```{r reproducibility3, echo = FALSE}
## Session info
options(width = 120)
session_info()
```

## Pandoc version used: `r rmarkdown::pandoc_version()`.

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>